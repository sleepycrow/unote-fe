(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~main"],{

/***/ "./node_modules/idb-keyval/dist/idb-keyval.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/idb-keyval/dist/idb-keyval.mjs ***!
  \*****************************************************/
/*! exports provided: Store, get, set, del, clear, keys */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"del\", function() { return del; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clear\", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\nclass Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/idb-keyval/dist/idb-keyval.mjs?");

/***/ }),

/***/ "./node_modules/js-cookie/src/js.cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/js-cookie/src/js.cookie.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * JavaScript Cookie v2.2.0\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader = false;\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (( false ? undefined : _typeof(exports)) === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n})(function () {\n\tfunction extend() {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[i];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction init(converter) {\n\t\tfunction api(key, value, attributes) {\n\t\t\tvar result;\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Write\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tattributes = extend({\n\t\t\t\t\tpath: '/'\n\t\t\t\t}, api.defaults, attributes);\n\n\t\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\t\tvar expires = new Date();\n\t\t\t\t\texpires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\n\t\t\t\t\tattributes.expires = expires;\n\t\t\t\t}\n\n\t\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = JSON.stringify(value);\n\t\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\tif (!converter.write) {\n\t\t\t\t\tvalue = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = converter.write(value, key);\n\t\t\t\t}\n\n\t\t\t\tkey = encodeURIComponent(String(key));\n\t\t\t\tkey = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\n\t\t\t\tkey = key.replace(/[\\(\\)]/g, escape);\n\n\t\t\t\tvar stringifiedAttributes = '';\n\n\t\t\t\tfor (var attributeName in attributes) {\n\t\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName];\n\t\t\t\t}\n\t\t\t\treturn document.cookie = key + '=' + value + stringifiedAttributes;\n\t\t\t}\n\n\t\t\t// Read\n\n\t\t\tif (!key) {\n\t\t\t\tresult = {};\n\t\t\t}\n\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t\t// calling \"get()\"\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar rdecode = /(%[0-9A-Z]{2})+/g;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!this.json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = parts[0].replace(rdecode, decodeURIComponent);\n\t\t\t\t\tcookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);\n\n\t\t\t\t\tif (this.json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tresult = cookie;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\tresult[name] = cookie;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tapi.set = api;\n\t\tapi.get = function (key) {\n\t\t\treturn api.call(api, key);\n\t\t};\n\t\tapi.getJSON = function () {\n\t\t\treturn api.apply({\n\t\t\t\tjson: true\n\t\t\t}, [].slice.call(arguments));\n\t\t};\n\t\tapi.defaults = {};\n\n\t\tapi.remove = function (key, attributes) {\n\t\t\tapi(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n});\n\n//# sourceURL=webpack:///./node_modules/js-cookie/src/js.cookie.js?");

/***/ }),

/***/ "./node_modules/riot-observable/dist/observable.js":
/*!*********************************************************!*\
  !*** ./node_modules/riot-observable/dist/observable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n;(function (window, undefined) {\n  var observable = function observable(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n        slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function value(event, fn) {\n          if (typeof fn == 'function') (callbacks[event] = callbacks[event] || []).push(fn);\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function value(event, fn) {\n          if (event == '*' && !fn) callbacks = {};else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) arr.splice(i--, 1);\n              }\n            } else delete callbacks[event];\n          }\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function value(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on);\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function value(event) {\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n              args = new Array(arglen),\n              fns,\n              fn,\n              i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*') el.trigger.apply(el, ['*', event].concat(args));\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el;\n  };\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (( false ? undefined : _typeof(exports)) === 'object') module.exports = observable;else if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return observable;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(typeof window != 'undefined' ? window : undefined);\n\n//# sourceURL=webpack:///./node_modules/riot-observable/dist/observable.js?");

/***/ }),

/***/ "./node_modules/riot-route/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/riot-route/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _riotObservable = __webpack_require__(/*! riot-observable */ \"./node_modules/riot-observable/dist/observable.js\");\n\nvar _riotObservable2 = _interopRequireDefault(_riotObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^/]+/,\n    EVENT_LISTENER = 'EventListener',\n    REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n    ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n    HAS_ATTRIBUTE = 'hasAttribute',\n    POPSTATE = 'popstate',\n    HASHCHANGE = 'hashchange',\n    TRIGGER = 'trigger',\n    MAX_EMIT_STACK_LEVEL = 3,\n    win = typeof window != 'undefined' && window,\n    doc = typeof document != 'undefined' && document,\n    hist = win && history,\n    loc = win && (hist.location || win.location),\n    // see html5-history-api\nprot = Router.prototype,\n    // to minify more\nclickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n    central = (0, _riotObservable2.default)();;;;;;;;;;;;;;;;\n\nvar started = false,\n    routeFound = false,\n    debouncedEmit,\n    base,\n    current,\n    parser,\n    secondParser,\n    emitStack = [],\n    emitStackLevel = 0;;;;;;;;;\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/);\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var f = filter.replace(/\\?/g, '\\\\?').replace(/\\*/g, '([^/?#]+?)').replace(/\\.\\./, '.*');\n  var re = new RegExp(\"^\" + f + \"$\");\n  var args = path.match(re);\n\n  if (args) {\n    return args.slice(1);\n  }\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t;\n  return function () {\n    clearTimeout(t);\n    t = setTimeout(fn, delay);\n  };\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1);\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n  doc[ADD_EVENT_LISTENER](clickEvent, click);\n  if (autoExec) {\n    emit(true);\n  }\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = [];\n  (0, _riotObservable2.default)(this); // make it observable\n  central.on('stop', this.s.bind(this));\n  central.on('emit', this.e.bind(this));\n}\n\nfunction normalize(path) {\n  return path.replace(/^\\/|\\/$/, '');\n}\n\nfunction isString(str) {\n  return typeof str == 'string';\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href).replace(RE_ORIGIN, '');\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] === '#' ? (href || loc.href || '').split(base)[1] || '' : (loc ? getPathFromRoot(href) : href || '').replace(base, '');\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel === 0;\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) {\n    return;\n  }\n\n  emitStackLevel++;\n  emitStack.push(function () {\n    var path = getPathFromBase();\n    if (force || path !== current) {\n      central[TRIGGER]('emit', path);\n      current = path;\n    }\n  });\n  if (isRoot) {\n    var first;\n    while (first = emitStack.shift()) {\n      first();\n    } // stack increses within this call\n    emitStackLevel = 0;\n  }\n}\n\nfunction click(e) {\n  if (e.which !== 1 // not left click\n  || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n  || e.defaultPrevented // or default prevented\n  ) {\n      return;\n    }\n\n  var el = e.target;\n  while (el && el.nodeName !== 'A') {\n    el = el.parentNode;\n  }\n\n  if (!el || el.nodeName !== 'A' // not A tag\n  || el[HAS_ATTRIBUTE]('download') // has download attr\n  || !el[HAS_ATTRIBUTE]('href') // has no href attr\n  || el.target && el.target !== '_self' // another window or frame\n  || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n  ) {\n      return;\n    }\n\n  if (el.href !== loc.href && (el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n  || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n  || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n  || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n  )) {\n    return;\n  }\n\n  e.preventDefault();\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) {\n    return central[TRIGGER]('emit', getPathFromBase(path));\n  }\n\n  path = base + normalize(path);\n  title = title || doc.title;\n  // browsers ignores the second parameter `title`\n  shouldReplace ? hist.replaceState(null, title, path) : hist.pushState(null, title, path);\n  // so we need to set it manually\n  doc.title = title;\n  routeFound = false;\n  emit();\n  return routeFound;\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function (first, second, third) {\n  if (isString(first) && (!second || isString(second))) {\n    go(first, second, third || false);\n  } else if (second) {\n    this.r(first, second);\n  } else {\n    this.r('@', first);\n  }\n};\n\n/**\n * Stop routing\n */\nprot.s = function () {\n  this.off('*');\n  this.$ = [];\n};\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function (path) {\n  this.$.concat('@').some(function (filter) {\n    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args));\n      return routeFound = true; // exit from loop\n    }\n  }, this);\n};\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function (filter, action) {\n  if (filter !== '@') {\n    filter = '/' + normalize(filter);\n    this.$.push(filter);\n  }\n  this.on(filter, action);\n};\n\nvar mainRouter = new Router();\nvar route = mainRouter.m.bind(mainRouter);\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function () {\n  var newSubRouter = new Router();\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter);\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter);\n  return router;\n};\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function (arg) {\n  base = arg || '#';\n  current = getPathFromBase(); // recalculate current path\n};\n\n/** Exec routing right now **/\nroute.exec = function () {\n  emit(true);\n};\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function (fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER;\n    secondParser = DEFAULT_SECOND_PARSER;\n  }\n  if (fn) {\n    parser = fn;\n  }\n  if (fn2) {\n    secondParser = fn2;\n  }\n};\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function () {\n  var q = {};\n  var href = loc.href || current;\n  href.replace(/[?&](.+?)=([^&]*)/g, function (_, k, v) {\n    q[k] = v;\n  });\n  return q;\n};\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n    }\n    central[TRIGGER]('stop');\n    started = false;\n  }\n};\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n        start(autoExec);\n      } else {\n        document.onreadystatechange = function () {\n          if (document.readyState === 'interactive') {\n            // the timeout is needed to solve\n            // a weird safari bug https://github.com/riot/route/issues/33\n            setTimeout(function () {\n              start(autoExec);\n            }, 1);\n          }\n        };\n      }\n    }\n    started = true;\n  }\n};\n\n/** Prepare the router **/\nroute.base();\nroute.parser();\n\nexports.default = route;\n\n//# sourceURL=webpack:///./node_modules/riot-route/lib/index.js?");

/***/ }),

/***/ "./node_modules/riot/riot.js":
/*!***********************************!*\
  !*** ./node_modules/riot/riot.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* Riot v3.10.3, @license MIT */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(undefined, function (exports) {\n  'use strict';\n\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector);\n  }\n\n  var\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n  // tags instances cache\n  __TAGS_CACHE = [],\n\n  // tags implementation cache\n  __TAG_IMPL = {},\n      YIELD_TAG = 'yield',\n\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n\n  // riot specific prefixes or attributes\n  ATTRS_PREFIX = 'riot-',\n\n\n  // Riot Directives\n  REF_DIRECTIVES = ['ref', 'data-ref'],\n      IS_DIRECTIVE = 'data-is',\n      CONDITIONAL_DIRECTIVE = 'if',\n      LOOP_DIRECTIVE = 'each',\n      LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n      SHOW_DIRECTIVE = 'show',\n      HIDE_DIRECTIVE = 'hide',\n      KEY_DIRECTIVE = 'key',\n      RIOT_EVENTS_KEY = '__riot-events__',\n\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n      T_OBJECT = 'object',\n      T_UNDEF = 'undefined',\n      T_FUNCTION = 'function',\n      XLINK_NS = 'http://www.w3.org/1999/xlink',\n      SVG_NS = 'http://www.w3.org/2000/svg',\n      XLINK_REGEX = /^xlink:(\\w+)/,\n      WIN = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === T_UNDEF ? /* istanbul ignore next */undefined : window,\n\n\n  // special native tags that cannot be treated like the others\n  RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n      RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n      RE_EVENTS_PREFIX = /^on/,\n      RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n\n  // some DOM attributes must be normalized\n  CASE_SENSITIVE_ATTRIBUTES = {\n    'viewbox': 'viewBox',\n    'preserveaspectratio': 'preserveAspectRatio'\n  },\n\n  /**\n   * Matches boolean HTML attributes in the riot tag definition.\n   * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n   * @const {RegExp}\n   * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n   */\n  RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (WIN && WIN.document || /* istanbul ignore next */{}).documentMode | 0;\n\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n  function makeElement(name) {\n    return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name);\n  }\n\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n  function setAttribute(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n    if (xlink && xlink[1]) {\n      dom.setAttributeNS(XLINK_NS, xlink[1], val);\n    } else {\n      dom.setAttribute(name, val);\n    }\n  }\n\n  var styleNode;\n  // Create cache and shortcut to the correct property\n  var cssTextProp;\n  var byName = {};\n  var needsInject = false;\n\n  // skip the following code on the server\n  if (WIN) {\n    styleNode = function () {\n      // create a new style element with the correct type\n      var newNode = makeElement('style');\n      // replace any user node or insert the new one into the head\n      var userNode = $('style[type=riot]');\n\n      setAttribute(newNode, 'type', 'text/css');\n      /* istanbul ignore next */\n      if (userNode) {\n        if (userNode.id) {\n          newNode.id = userNode.id;\n        }\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else {\n        document.head.appendChild(newNode);\n      }\n\n      return newNode;\n    }();\n    cssTextProp = styleNode.styleSheet;\n  }\n\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n  var styleManager = {\n    styleNode: styleNode,\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      byName[name] = css;\n      needsInject = true;\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) {\n        return;\n      }\n      needsInject = false;\n      var style = Object.keys(byName).map(function (k) {\n        return byName[k];\n      }).join('\\n');\n      /* istanbul ignore next */\n      if (cssTextProp) {\n        cssTextProp.cssText = style;\n      } else {\n        styleNode.innerHTML = style;\n      }\n    },\n\n    /**\n     * Remove a tag style of injected DOM later.\n     * @param {String} name a registered tagname\n     */\n    remove: function remove(name) {\n      delete byName[name];\n      needsInject = true;\n    }\n\n    /**\n     * The riot template engine\n     * @version v3.0.8\n     */\n\n    /* istanbul ignore next */\n  };var skipRegex = function () {\n    //eslint-disable-line no-unused-vars\n\n    var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n    var beforeReWords = ['case', 'default', 'do', 'else', 'in', 'instanceof', 'prefix', 'return', 'typeof', 'void', 'yield'];\n\n    var wordsLastChar = beforeReWords.reduce(function (s, w) {\n      return s + w.slice(-1);\n    }, '');\n\n    var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n    var RE_VN_CHAR = /[$\\w]/;\n\n    function prev(code, pos) {\n      while (--pos >= 0 && /\\s/.test(code[pos])) {}\n      return pos;\n    }\n\n    function _skipRegex(code, start) {\n\n      var re = /.*/g;\n      var pos = re.lastIndex = start++;\n      var match = re.exec(code)[0].match(RE_REGEX);\n\n      if (match) {\n        var next = pos + match[0].length;\n\n        pos = prev(code, pos);\n        var c = code[pos];\n\n        if (pos < 0 || ~beforeReChars.indexOf(c)) {\n          return next;\n        }\n\n        if (c === '.') {\n\n          if (code[pos - 1] === '.') {\n            start = next;\n          }\n        } else if (c === '+' || c === '-') {\n\n          if (code[--pos] !== c || (pos = prev(code, pos)) < 0 || !RE_VN_CHAR.test(code[pos])) {\n            start = next;\n          }\n        } else if (~wordsLastChar.indexOf(c)) {\n\n          var end = pos + 1;\n\n          while (--pos >= 0 && RE_VN_CHAR.test(code[pos])) {}\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next;\n          }\n        }\n      }\n\n      return start;\n    }\n\n    return _skipRegex;\n  }();\n\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n  var brackets = function (UNDEF) {\n\n    var REGLOB = 'g',\n        R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n        R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n        S_QBLOCKS = R_STRINGS.source + '|' + /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' + /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n        UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n        NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n        S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n        FINDBRACES = {\n      '(': RegExp('([()])|' + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|' + S_QBLOCK2, REGLOB)\n    },\n        DEFAULT = '{ }';\n\n    var _pairs = ['{', '}', '{', '}', /{[^}]*}/, /\\\\([{}])/g, /\\\\({)|{/g, RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB), DEFAULT, /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/, /(^|[^\\\\]){=[\\S\\s]*?}/];\n\n    var cachedBrackets = UNDEF,\n        _regex,\n        _cache = [],\n        _settings;\n\n    function _loopback(re) {\n      return re;\n    }\n\n    function _rewrite(re, bp) {\n      if (!bp) {\n        bp = _cache;\n      }\n      return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '');\n    }\n\n    function _create(pair) {\n      if (pair === DEFAULT) {\n        return _pairs;\n      }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"');\n      }\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n      arr[8] = pair;\n      return arr;\n    }\n\n    function _brackets(reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];\n    }\n\n    _brackets.split = function split(str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) {\n        _bp = _cache;\n      }\n\n      var parts = [],\n          match,\n          isexpr,\n          start,\n          pos,\n          re = _bp[6];\n\n      var qblocks = [];\n      var prevStr = '';\n      var mark, lastIndex;\n\n      isexpr = start = re.lastIndex = 0;\n\n      while (match = re.exec(str)) {\n\n        lastIndex = re.lastIndex;\n        pos = match.index;\n\n        if (isexpr) {\n\n          if (match[2]) {\n\n            var ch = match[2];\n            var rech = FINDBRACES[ch];\n            var ix = 1;\n\n            rech.lastIndex = lastIndex;\n            while (match = rech.exec(str)) {\n              if (match[1]) {\n                if (match[1] === ch) {\n                  ++ix;\n                } else if (! --ix) {\n                  break;\n                }\n              } else {\n                rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n              }\n            }\n            re.lastIndex = ix ? str.length : rech.lastIndex;\n            continue;\n          }\n\n          if (!match[3]) {\n            re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n            continue;\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      parts.qblocks = qblocks;\n\n      return parts;\n\n      function unescapeStr(s) {\n        if (prevStr) {\n          s = prevStr + s;\n          prevStr = '';\n        }\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function pushQBlock(_pos, _lastIndex, slash) {\n        //eslint-disable-line\n        if (slash) {\n          _lastIndex = skipRegex(str, _pos);\n        }\n\n        if (tmpl && _lastIndex > _pos + 2) {\n          mark = '\\u2057' + qblocks.length + '~';\n          qblocks.push(str.slice(_pos, _lastIndex));\n          prevStr += str.slice(start, _pos) + mark;\n          start = _lastIndex;\n        }\n        return _lastIndex;\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr(str) {\n      return _cache[4].test(str);\n    };\n\n    _brackets.loopKeys = function loopKeys(expr) {\n      var m = expr.match(_cache[9]);\n\n      return m ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] } : { val: expr.trim() };\n    };\n\n    _brackets.array = function array(pair) {\n      return pair ? _create(pair) : _cache;\n    };\n\n    function _reset(pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n      cachedBrackets = pair;\n    }\n\n    function _setSettings(o) {\n      var b;\n\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function get() {\n          return cachedBrackets;\n        },\n        enumerable: true\n      });\n      _settings = o;\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function get() {\n        return _settings;\n      }\n    });\n\n    /* istanbul ignore next: in the browser riot is always in the scope */\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n    _brackets.skipRegex = skipRegex;\n\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n    _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n    return _brackets;\n  }();\n\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n  var tmpl = function () {\n\n    var _cache = {};\n\n    function _tmpl(str, data) {\n      if (!str) {\n        return str;\n      }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr.bind({\n        data: data,\n        tmpl: str\n      }));\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n\n    _tmpl.loopKeys = brackets.loopKeys;\n\n    // istanbul ignore next\n    _tmpl.clearCache = function () {\n      _cache = {};\n    };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr(err, ctx) {\n\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id //eslint-disable-line camelcase\n      };\n\n      if (_tmpl.errorHandler) {\n        _tmpl.errorHandler(err);\n      } else if (typeof console !== 'undefined' && typeof console.error === 'function') {\n        console.error(err.message);\n        console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n        console.log(this.data); // eslint-disable-line\n      }\n    }\n\n    function _create(str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') {\n        expr = 'return ' + expr;\n      }\n\n      return new Function('E', expr + ';'); // eslint-disable-line no-new-func\n    }\n\n    var RE_DQUOTE = /\\u2057/g;\n    var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl(str) {\n      var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n      var qstr = parts.qblocks;\n      var expr;\n\n      if (parts.length > 2 || parts[0]) {\n        var i,\n            j,\n            list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n\n          expr = parts[i];\n\n          if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '\"' + expr.replace(/\\\\/g, '\\\\\\\\').replace(/\\r\\n?|\\n/g, '\\\\n').replace(/\"/g, '\\\\\"') + '\"')) {\n            list[j++] = expr;\n          }\n        }\n\n        expr = j < 2 ? list[0] : '[' + list.join(',') + '].join(\"\")';\n      } else {\n\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr.length) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos].replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n');\n        });\n      }\n      return expr;\n    }\n\n    var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n    var RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n    function _parseExpr(expr, asText, qstr) {\n\n      expr = expr.replace(/\\s+/g, ' ').trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var list = [],\n            cnt = 0,\n            match;\n\n        while (expr && (match = expr.match(RE_CSNAME)) && !match.index) {\n          var key,\n              jsb,\n              re = /,|([[{(])|$/g;\n\n          expr = RegExp.rightContext;\n          key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) {\n            skipBraces(jsb, re);\n          }\n\n          jsb = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n      return expr;\n\n      function skipBraces(ch, re) {\n        var mm,\n            lv = 1,\n            ir = RE_BREND[ch];\n\n        ir.lastIndex = re.lastIndex;\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) {\n            ++lv;\n          } else if (! --lv) {\n            break;\n          }\n        }\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    }\n\n    // istanbul ignore next: not both\n    var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' ? 'global' : 'window') + ').',\n        JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n        JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr(expr, asText, key) {\n      var tb;\n\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n            if (pos) {\n              tb = (s = s[pos]) === '.' || s === '(' || s === '[';\n            }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n        return match;\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n\n        expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?\"' + key + '\":\"\"';\n      } else if (asText) {\n\n        expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr;\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.8';\n\n    return _tmpl;\n  }();\n\n  /* istanbul ignore next */\n  var observable = function observable(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n        slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function value(event, fn) {\n          if (typeof fn == 'function') {\n            (callbacks[event] = callbacks[event] || []).push(fn);\n          }\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function value(event, fn) {\n          if (event == '*' && !fn) {\n            callbacks = {};\n          } else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) {\n                  arr.splice(i--, 1);\n                }\n              }\n            } else {\n              delete callbacks[event];\n            }\n          }\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function value(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on);\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function value(event) {\n          var arguments$1 = arguments;\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n              args = new Array(arglen),\n              fns,\n              fn,\n              i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*') {\n            el.trigger.apply(el, ['*', event].concat(args));\n          }\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el;\n  };\n\n  /**\n   * Short alias for Object.getOwnPropertyDescriptor\n   */\n  function getPropDescriptor(o, k) {\n    return Object.getOwnPropertyDescriptor(o, k);\n  }\n\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isUndefined(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_UNDEF;\n  }\n\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } true if writable\n   */\n  function isWritable(obj, key) {\n    var descriptor = getPropDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable;\n  }\n\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n  function extend(src) {\n    var obj;\n    var i = 1;\n    var args = arguments;\n    var l = args.length;\n\n    for (; i < l; i++) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key)) {\n            src[key] = obj[key];\n          }\n        }\n      }\n    }\n    return src;\n  }\n\n  /**\n   * Alias for Object.create\n   */\n  function create(src) {\n    return Object.create(src);\n  }\n\n  var settings = extend(create(brackets.settings), {\n    skipAnonymousTags: true,\n    // handle the auto updates on any DOM event\n    autoUpdate: true\n  });\n\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n  function $$(selector, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(selector));\n  }\n\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n  function createDOMPlaceholder() {\n    return document.createTextNode('');\n  }\n\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom.hidden = show ? false : true;\n  }\n\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n  function getAttribute(dom, name) {\n    return dom.getAttribute(name);\n  }\n\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n  function removeAttribute(dom, name) {\n    dom.removeAttribute(name);\n  }\n\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   * @param { Boolean } isSvg - svg tags should be treated a bit differently\n   */\n  /* istanbul ignore next */\n  function setInnerHTML(container, html, isSvg) {\n    // innerHTML is not supported on svg tags so we neet to treat them differently\n    if (isSvg) {\n      var node = container.ownerDocument.importNode(new DOMParser().parseFromString(\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\", 'application/xml').documentElement, true);\n\n      container.appendChild(node);\n    } else {\n      container.innerHTML = html;\n    }\n  }\n\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n  function walkAttributes(html, fn) {\n    if (!html) {\n      return;\n    }\n    var m;\n    while (m = RE_HTML_ATTRS.exec(html)) {\n      fn(m[1].toLowerCase(), m[2] || m[3] || m[4]);\n    }\n  }\n\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n  function createFragment() {\n    return document.createDocumentFragment();\n  }\n\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return acc + \" \" + prop + \": \" + style[prop] + \";\";\n    }, '');\n  }\n\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next;\n      // stop the recursion\n      if (res === false) {\n        return;\n      }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n  var dom = /*#__PURE__*/Object.freeze({\n    $$: $$,\n    $: $,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: makeElement,\n    setAttr: setAttribute,\n    toggleVisibility: toggleVisibility,\n    getAttr: getAttribute,\n    remAttr: removeAttribute,\n    setInnerHTML: setInnerHTML,\n    walkAttrs: walkAttributes,\n    createFrag: createFragment,\n    safeInsert: safeInsert,\n    styleObjectToString: styleObjectToString,\n    walkNodes: walkNodes\n  });\n\n  /**\n   * Check against the null and undefined values\n   * @param   { * }  value -\n   * @returns {Boolean} -\n   */\n  function isNil(value) {\n    return isUndefined(value) || value === null;\n  }\n\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n  function isBlank(value) {\n    return isNil(value) || value === '';\n  }\n\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isFunction(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_FUNCTION;\n  }\n\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isObject(value) {\n    return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_OBJECT; // typeof null is 'object'\n  }\n\n  /**\n   * Check if a DOM node is an svg tag or part of an svg\n   * @param   { HTMLElement }  el - node we want to test\n   * @returns {Boolean} true if it's an svg node\n   */\n  function isSvg(el) {\n    var owner = el.ownerSVGElement;\n    return !!owner || owner === null;\n  }\n\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array;\n  }\n\n  /**\n   * Check if the passed argument is a boolean attribute\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value);\n  }\n\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isString(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_STRING;\n  }\n\n  var check = /*#__PURE__*/Object.freeze({\n    isBlank: isBlank,\n    isFunction: isFunction,\n    isObject: isObject,\n    isSvg: isSvg,\n    isWritable: isWritable,\n    isArray: isArray,\n    isBoolAttr: isBoolAttr,\n    isNil: isNil,\n    isString: isString,\n    isUndefined: isUndefined\n  });\n\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n  function contains(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n    for (; i < len; i++) {\n      fn(list[i], i);\n    }\n    return list;\n  }\n\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value;\n  }\n\n  /**\n   * Function returning always a unique identifier\n   * @returns { Number } - number from 0...n\n   */\n  var uid = function uid() {\n    var i = -1;\n    return function () {\n      return ++i;\n    };\n  }();\n\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n  function define(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el;\n  }\n\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) {\n      return c.toUpperCase();\n    });\n  }\n\n  /**\n   * Warn a message via console\n   * @param   {String} message - warning message\n   */\n  function warn(message) {\n    if (console && console.warn) {\n      console.warn(message);\n    }\n  }\n\n  var misc = /*#__PURE__*/Object.freeze({\n    contains: contains,\n    each: each,\n    getPropDescriptor: getPropDescriptor,\n    startsWith: startsWith,\n    uid: uid,\n    defineProperty: define,\n    objectCreate: create,\n    extend: extend,\n    toCamel: toCamel,\n    warn: warn\n  });\n\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) {\n      return;\n    }\n\n    // if the key was never set, set it once\n    if (!dest && ensureArray) {\n      obj[key] = [value];\n    } else if (!dest) {\n      obj[key] = value;\n    }\n    // if it was an array and not yet set\n    else {\n        if (isArr) {\n          var oldIndex = dest.indexOf(value);\n          // this item never changed its position\n          if (oldIndex === index) {\n            return;\n          }\n          // remove the item from its old position\n          if (oldIndex !== -1) {\n            dest.splice(oldIndex, 1);\n          }\n          // move or add the item\n          if (hasIndex) {\n            dest.splice(index, 0, value);\n          } else {\n            dest.push(value);\n          }\n        } else {\n          obj[key] = [dest, value];\n        }\n      }\n  }\n\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n  function get(dom) {\n    return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) || getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()];\n  }\n\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n  function getName(dom, skipDataIs) {\n    var child = get(dom);\n    var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();\n  }\n\n  /**\n   * Return a temporary context containing also the parent properties\n   * @this Tag\n   * @param { Tag } - temporary tag context containing all the parent properties\n   */\n  function inheritParentProps() {\n    if (this.parent) {\n      return extend(create(this), this.parent);\n    }\n    return this;\n  }\n\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n  var reHasYield = /<yield\\b/i,\n      reYieldAll = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n      reYieldSrc = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n      reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n      rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n      tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n      GENERIC = 'div',\n      SVG = 'svg';\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, tmpl, tagName) {\n\n    var select = tagName[0] === 'o',\n        parent = select ? 'select>' : 'table>';\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild;\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    /* istanbul ignore next */\n    if (select) {\n      parent.selectedIndex = -1; // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n      if (tname && parent.childElementCount === 1) {\n        parent = $(tname, parent);\n      }\n    }\n    return parent;\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) {\n      return tmpl;\n    }\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {};\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text; // preserve first definition\n      return '';\n    }).trim();\n\n    return tmpl.replace(reYieldDest, function (_, ref, def) {\n      // yield with from - to attrs\n      return src[ref] || def || '';\n    }).replace(reYieldAll, function (_, def) {\n      // yield without any \"from\"\n      return html || def || '';\n    });\n  }\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } isSvg - true if the root node is an svg\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n  function mkdom(tmpl, html, isSvg) {\n    var match = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n    var tagName = match && match[1].toLowerCase();\n    var el = makeElement(isSvg ? SVG : GENERIC);\n\n    // replace all the yield tags with the tag inner html\n    tmpl = replaceYield(tmpl, html);\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName)) {\n      el = specialTags(el, tmpl, tagName);\n    } else {\n      setInnerHTML(el, tmpl, isSvg);\n    }\n\n    return el;\n  }\n\n  var EVENT_ATTR_RE = /^on/;\n\n  /**\n   * True if the event attribute starts with 'on'\n   * @param   { String } attribute - event attribute\n   * @returns { Boolean }\n   */\n  function isEventAttribute(attribute) {\n    return EVENT_ATTR_RE.test(attribute);\n  }\n\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n  function getImmediateCustomParent(tag) {\n    var ptag = tag;\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) {\n        break;\n      }\n      ptag = ptag.parent;\n    }\n    return ptag;\n  }\n\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent;\n    var item = this.__.item;\n\n    if (!item) {\n      while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      }\n    }\n\n    // override the event properties\n    /* istanbul ignore next */\n    if (isWritable(e, 'currentTarget')) {\n      e.currentTarget = dom;\n    }\n    /* istanbul ignore next */\n    if (isWritable(e, 'target')) {\n      e.target = e.srcElement;\n    }\n    /* istanbul ignore next */\n    if (isWritable(e, 'which')) {\n      e.which = e.charCode || e.keyCode;\n    }\n\n    e.item = item;\n\n    handler.call(this, e);\n\n    // avoid auto updates\n    if (!settings.autoUpdate) {\n      return;\n    }\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParent(this);\n      // fixes #2083\n      if (p.isMounted) {\n        p.update();\n      }\n    }\n  }\n\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName;\n    var cb = handleEvent.bind(tag, dom, handler);\n\n    // avoid to bind twice the same event\n    // possible fix for #2332\n    dom[name] = null;\n\n    // normalize event name\n    eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n    // cache the listener into the listeners array\n    if (!contains(tag.__.listeners, dom)) {\n      tag.__.listeners.push(dom);\n    }\n    if (!dom[RIOT_EVENTS_KEY]) {\n      dom[RIOT_EVENTS_KEY] = {};\n    }\n    if (dom[RIOT_EVENTS_KEY][name]) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]);\n    }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n  function initChild(child, opts, innerHTML, parent) {\n    var tag = createTag(child, opts, innerHTML);\n    var tagName = opts.tagName || getName(opts.root, true);\n    var ptag = getImmediateCustomParent(parent);\n    // fix for the parent attribute in the looped elements\n    define(tag, 'parent', ptag);\n    // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n    tag.__.parent = parent;\n\n    // add this tag to the custom parent tag\n    arrayishAdd(ptag.tags, tagName, tag);\n\n    // and also to the real parent tag\n    if (ptag !== parent) {\n      arrayishAdd(parent.tags, tagName, tag);\n    }\n\n    return tag;\n  }\n\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n      if (index !== -1) {\n        obj[key].splice(index, 1);\n      }\n      if (!obj[key].length) {\n        delete obj[key];\n      } else if (obj[key].length === 1 && !ensureArray) {\n        obj[key] = obj[key][0];\n      }\n    } else if (obj[key] === value) {\n      delete obj[key];\n    } // otherwise just delete the key\n  }\n\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n  function makeVirtual(src, target) {\n    var this$1 = this;\n\n    var head = createDOMPlaceholder();\n    var tail = createDOMPlaceholder();\n    var frag = createFragment();\n    var sib;\n    var el;\n\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      this$1.__.virts.push(el); // hold for unmounting\n      el = sib;\n    }\n\n    if (target) {\n      src.insertBefore(frag, target.__.head);\n    } else {\n      src.appendChild(frag);\n    }\n  }\n\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n  function makeReplaceVirtual(tag, ref) {\n    var frag = createFragment();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n  function updateDataIs(expr, parent, tagName) {\n    var tag = expr.tag || expr.dom._tag;\n    var ref;\n\n    var ref$1 = tag ? tag.__ : {};\n    var head = ref$1.head;\n    var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n    if (tag && expr.tagName === tagName) {\n      tag.update();\n      return;\n    }\n\n    // sync _parent to accommodate changing tagnames\n    if (tag) {\n      // need placeholder before unmount\n      if (isVirtual) {\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      tag.unmount(true);\n    }\n\n    // unable to get the tag name\n    if (!isString(tagName)) {\n      return;\n    }\n\n    expr.impl = __TAG_IMPL[tagName];\n\n    // unknown implementation\n    if (!expr.impl) {\n      return;\n    }\n\n    expr.tag = tag = initChild(expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    }, expr.dom.innerHTML, parent);\n\n    each(expr.attrs, function (a) {\n      return setAttribute(tag.root, a.name, a.value);\n    });\n    expr.tagName = tagName;\n    tag.mount();\n\n    // root exist first time, after use placeholder\n    if (isVirtual) {\n      makeReplaceVirtual(tag, ref || tag.root);\n    }\n\n    // parent is the placeholder tag, not the dynamic tag so clean up\n    parent.__.onUnmount = function () {\n      var delName = tag.opts.dataIs;\n      arrayishRemove(tag.parent.tags, delName, tag);\n      arrayishRemove(tag.__.parent.tags, delName, tag);\n      tag.unmount();\n    };\n  }\n\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n  function normalizeAttrName(attrName) {\n    if (!attrName) {\n      return null;\n    }\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) {\n      attrName = CASE_SENSITIVE_ATTRIBUTES[attrName];\n    }\n    return attrName;\n  }\n\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n  function updateExpression(expr) {\n    if (this.root && getAttribute(this.root, 'virtualized')) {\n      return;\n    }\n\n    var dom = expr.dom;\n    // remove the riot- prefix\n    var attrName = normalizeAttrName(expr.attr);\n    var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n    var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var parent = dom && (expr.parent || dom.parentNode);\n    // detect the style attributes\n    var isStyleAttr = attrName === 'style';\n    var isClassAttr = attrName === 'class';\n\n    var value;\n\n    // if it's a tag we could totally skip the rest\n    if (expr._riot_id) {\n      if (expr.__.wasCreated) {\n        expr.update();\n        // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n      return;\n    }\n\n    // if this expression has the update method it means it can handle the DOM changes by itself\n    if (expr.update) {\n      return expr.update();\n    }\n\n    var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n    // ...it seems to be a simple expression so we try to calculate its value\n    value = tmpl(expr.expr, context);\n\n    var hasValue = !isBlank(value);\n    var isObj = isObject(value);\n\n    // convert the style/class objects to strings\n    if (isObj) {\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    }\n\n    // remove original attribute\n    if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n      // remove either riot-* attributes or just the attribute name\n      removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n    }\n\n    // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n    if (expr.bool) {\n      value = value ? attrName : false;\n    }\n    if (expr.isRtag) {\n      return updateDataIs(expr, this, value);\n    }\n    if (expr.wasParsedOnce && expr.value === value) {\n      return;\n    }\n\n    // update the expression value\n    expr.value = value;\n    expr.wasParsedOnce = true;\n\n    // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n    if (isObj && !isClassAttr && !isStyleAttr && !isToggle) {\n      return;\n    }\n    // avoid to render undefined/null values\n    if (!hasValue) {\n      value = '';\n    }\n\n    // textarea and text nodes have no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += '';\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value; // #1113\n          if (!IE_VERSION) {\n            dom.nodeValue = value;\n          } // #1625 IE throws here, nodeValue\n        } // will be available on 'updated'\n        else {\n            dom.nodeValue = value;\n          }\n      }\n      return;\n    }\n\n    switch (true) {\n      // handle events binding\n      case isFunction(value):\n        if (isEventAttribute(attrName)) {\n          setEventHandler(attrName, value, dom, this);\n        }\n        break;\n      // show / hide\n      case isToggle:\n        toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n        break;\n      // handle attributes\n      default:\n        if (expr.bool) {\n          dom[attrName] = value;\n        }\n\n        if (attrName === 'value' && dom.value !== value) {\n          dom.value = value;\n        } else if (hasValue && value !== false) {\n          setAttribute(dom, attrName, value);\n        }\n\n        // make sure that in case of style changes\n        // the element stays hidden\n        if (isStyleAttr && dom.hidden) {\n          toggleVisibility(dom, false);\n        }\n    }\n  }\n\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n  function update(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) {\n      return;\n    }\n    var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n    each(instAttrs, function (attr) {\n      if (attr.expr) {\n        updateExpression.call(ctx, attr.expr);\n      }\n      // normalize the attribute names\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param { Tag } tag - tag object\n   * @param { * } data - data we want to use to extend the tag properties\n   * @param { Array } expressions - component expressions array\n   * @returns { Tag } the current tag instance\n   */\n  function componentUpdate(tag, data, expressions) {\n    var __ = tag.__;\n    var nextOpts = {};\n    var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n    // inherit properties from the parent tag\n    if (__.isAnonymous && __.parent) {\n      extend(tag, __.parent);\n    }\n    extend(tag, data);\n\n    updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n    if (canTrigger && tag.isMounted && isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)) {\n      return tag;\n    }\n\n    extend(tag.opts, nextOpts);\n\n    if (canTrigger) {\n      tag.trigger('update', data);\n    }\n    update.call(tag, expressions);\n    if (canTrigger) {\n      tag.trigger('updated');\n    }\n\n    return tag;\n  }\n\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n  function query(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + query(keys);\n    }\n\n    return tags.filter(function (t) {\n      return !/[^-\\w]/.test(t);\n    }).reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\";\n    }, '');\n  }\n\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n  function Tag(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate;\n    // register a new tag and cache the class prototype\n    if (!__TAG_IMPL[name]) {\n      tag(name, tmpl, css, attrs, onCreate);\n      // cache the class constructor\n      __TAG_IMPL[name].class = this.constructor;\n    }\n\n    // mount the tag using the class instance\n    mount$1(el, name, opts, this);\n    // inject the component css\n    if (css) {\n      styleManager.inject();\n    }\n\n    return this;\n  }\n\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else {\n        attrs = '';\n      }\n    }\n\n    if (css) {\n      if (isFunction(css)) {\n        fn = css;\n      } else {\n        styleManager.add(css, name);\n      }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name;\n  }\n\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag2(name, tmpl, css, attrs, fn) {\n    if (css) {\n      styleManager.add(css, name);\n    }\n\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name;\n  }\n\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n  function mount(selector, tagName, opts) {\n    var tags = [];\n    var elem, allTags;\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttribute(root, IS_DIRECTIVE),\n            tag;\n\n        // have tagName? force riot-tag to be the same\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttribute(root, IS_DIRECTIVE, tagName);\n        }\n\n        tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n        if (tag) {\n          tags.push(tag);\n        }\n      } else if (root.length) {\n        each(root, pushTagsTo);\n      } // assume nodeList\n    }\n\n    // inject styles into DOM\n    styleManager.inject();\n\n    if (isObject(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    }\n\n    // crawl the DOM to find the tag\n    if (isString(selector)) {\n      selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = query() :\n      // or just the ones named like the selector\n      selector + query(selector.split(/, */));\n\n      // make sure to pass always a selector\n      // to the querySelectorAll function\n      elem = selector ? $$(selector) : [];\n    } else\n      // probably you have passed already a tag or a NodeList\n      {\n        elem = selector;\n      }\n\n    // select all the registered and mount them inside their root elements\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || query();\n      // if the root els it's just a single tag\n      if (elem.tagName) {\n        elem = $$(tagName, elem);\n      } else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n\n        each(elem, function (_el) {\n          return nodeList.push($$(tagName, _el));\n        });\n\n        elem = nodeList;\n      }\n      // get rid of the tagName\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n\n    return tags;\n  }\n\n  // Create a mixin that could be globally shared across all the tags\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  function mixin(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin(\"__\" + mixins_id++ + \"__\", name, true);\n      return;\n    }\n\n    var store = g ? globals : mixins;\n\n    // Getter\n    if (!mix) {\n      if (isUndefined(store[name])) {\n        throw new Error(\"Unregistered mixin: \" + name);\n      }\n\n      return store[name];\n    }\n\n    // Setter\n    store[name] = isFunction(mix) ? extend(mix.prototype, store[name] || {}) && mix : extend(store[name] || {}, mix);\n  }\n\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) {\n      return tag.update();\n    });\n  }\n\n  function unregister(name) {\n    styleManager.remove(name);\n    return delete __TAG_IMPL[name];\n  }\n\n  var version = 'v3.10.3';\n\n  var core = /*#__PURE__*/Object.freeze({\n    Tag: Tag,\n    tag: tag,\n    tag2: tag2,\n    mount: mount,\n    mixin: mixin,\n    update: update$1,\n    unregister: unregister,\n    version: version\n  });\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  function componentMixin(tag$$1) {\n    var mixins = [],\n        len = arguments.length - 1;\n    while (len-- > 0) {\n      mixins[len] = arguments[len + 1];\n    }each(mixins, function (mix) {\n      var instance;\n      var obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else {\n        instance = mix;\n      }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do {\n        props = props.concat(Object.getOwnPropertyNames(obj || instance));\n      } while (obj = Object.getPrototypeOf(obj || instance));\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to tag\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(tag$$1, key, descriptor);\n          } else {\n            tag$$1[key] = isFunction(instance[key]) ? instance[key].bind(tag$$1) : instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init) {\n        instance.init.bind(tag$$1)(tag$$1.opts);\n      }\n    });\n\n    return tag$$1;\n  }\n\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n  function moveChild(tagName, newPos) {\n    var parent = this.parent;\n    var tags;\n    // no parent no move\n    if (!parent) {\n      return;\n    }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags)) {\n      tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]);\n    } else {\n      arrayishAdd(parent.tags, tagName, this);\n    }\n  }\n\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n  function moveVirtual(src, target) {\n    var this$1 = this;\n\n    var el = this.__.head;\n    var sib;\n    var frag = createFragment();\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n  function mkitem(expr, key, val) {\n    var item = {};\n    item[expr.key] = key;\n    if (expr.pos) {\n      item[expr.pos] = val;\n    }\n    return item;\n  }\n\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n  function unmountRedundant(items, tags, filteredItemsCount) {\n    var i = tags.length;\n    var j = items.length - filteredItemsCount;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n  function moveNestedTags(i) {\n    var this$1 = this;\n\n    each(Object.keys(this.tags), function (tagName) {\n      moveChild.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      moveVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function append(root, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.call(this, root);\n    } else {\n      root.appendChild(this.root);\n    }\n  }\n\n  /**\n   * Return the value we want to use to lookup the postion of our items in the collection\n   * @param   { String }  keyAttr         - lookup string or expression\n   * @param   { * }       originalItem    - original item from the collection\n   * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n   * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n   * @returns { * } value that we will use to figure out the item position via collection.indexOf\n   */\n  function getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n    if (keyAttr) {\n      return hasKeyAttrExpr ? tmpl(keyAttr, keyedItem) : originalItem[keyAttr];\n    }\n\n    return originalItem;\n  }\n\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n  function _each(dom, parent, expr) {\n    var mustReorder = _typeof(getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE)) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n    var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n    var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n    var tagName = getName(dom);\n    var impl = __TAG_IMPL[tagName];\n    var parentNode = dom.parentNode;\n    var placeholder = createDOMPlaceholder();\n    var child = get(dom);\n    var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n    var tags = [];\n    var isLoop = true;\n    var innerHTML = dom.innerHTML;\n    var isAnonymous = !__TAG_IMPL[tagName];\n    var isVirtual = dom.tagName === 'VIRTUAL';\n    var oldItems = [];\n\n    // remove the each property from the original tag\n    removeAttribute(dom, LOOP_DIRECTIVE);\n    removeAttribute(dom, KEY_DIRECTIVE);\n\n    // parse the each expression\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n    }\n\n    // insert a marked where the loop tags will be injected\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n\n      var items = expr.value;\n      var frag = createFragment();\n      var isObject = !isArray(items) && !isString(items);\n      var root = placeholder.parentNode;\n      var tmpItems = [];\n      var hasKeys = isObject && !!items;\n\n      // if this DOM was removed the update here is useless\n      // this condition fixes also a weird async issue on IE in our unit test\n      if (!root) {\n        return;\n      }\n\n      // object loop. any changes cause full redraw\n      if (isObject) {\n        items = items ? Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key);\n        }) : [];\n      }\n\n      // store the amount of filtered items\n      var filteredItemsCount = 0;\n\n      // loop all the new items\n      each(items, function (_item, index) {\n        var i = index - filteredItemsCount;\n        var item = !hasKeys && expr.key ? mkitem(expr, _item, index) : _item;\n\n        // skip this item because it must be filtered\n        if (ifExpr && !tmpl(ifExpr, extend(create(parent), item))) {\n          filteredItemsCount++;\n          return;\n        }\n\n        var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n        // reorder only if the items are not objects\n        // or a key attribute has been provided\n        var doReorder = !isObject && mustReorder && (typeof _item === 'undefined' ? 'undefined' : _typeof(_item)) === T_OBJECT || keyAttr;\n        var oldPos = oldItems.indexOf(itemId);\n        var isNew = oldPos === -1;\n        var pos = !isNew && doReorder ? oldPos : i;\n        // does a tag exist in this position?\n        var tag = tags[pos];\n        var mustAppend = i >= oldItems.length;\n        var mustCreate = doReorder && isNew || !doReorder && !tag || !tags[i];\n\n        // new tag\n        if (mustCreate) {\n          tag = createTag(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i\n          }, innerHTML);\n\n          // mount the tag\n          tag.mount();\n\n          if (mustAppend) {\n            append.apply(tag, [frag || root, isVirtual]);\n          } else {\n            insert.apply(tag, [root, tags[i], isVirtual]);\n          }\n\n          if (!mustAppend) {\n            oldItems.splice(i, 0, item);\n          }\n          tags.splice(i, 0, tag);\n          if (child) {\n            arrayishAdd(parent.tags, tagName, tag, true);\n          }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (keyAttr || contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]);\n            // move the old tag instance\n            tags.splice(i, 0, tags.splice(pos, 1)[0]);\n            // move the old item\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          }\n\n          // update the position attribute if it exists\n          if (expr.pos) {\n            tag[expr.pos] = i;\n          }\n\n          // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n          if (!child && tag.tags) {\n            moveNestedTags.call(tag, i);\n          }\n        }\n\n        // cache the original item to use it in the events bound to this node\n        // and its children\n        extend(tag.__, {\n          item: item,\n          index: i,\n          parent: parent\n        });\n\n        tmpItems[i] = itemId;\n\n        if (!mustCreate) {\n          tag.update(item);\n        }\n      });\n\n      // remove the redundant tags\n      unmountRedundant(items, tags, filteredItemsCount);\n\n      // clone the items array\n      oldItems = tmpItems.slice();\n\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) {\n        t.unmount();\n      });\n    };\n\n    return expr;\n  }\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this;\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n      var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n      // the name changed, so we need to remove it from the old key (if present)\n      if (!isBlank(old) && customParent) {\n        arrayishRemove(customParent.refs, old, tagOrDom);\n      }\n      if (!isBlank(this.value) && isString(this.value)) {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) {\n          arrayishAdd(customParent.refs, this.value, tagOrDom,\n          // use an array if it's a looped node and the ref is not an expression\n          null, this.parent.__.index);\n        }\n\n        if (this.value !== old) {\n          setAttribute(this.dom, this.attr, this.value);\n        }\n      } else {\n        removeAttribute(this.dom, this.attr);\n      }\n\n      // cache the ref bound to this dom node\n      // to reuse it in future (see also #2329)\n      if (!this.dom.__ref) {\n        this.dom.__ref = tagOrDom;\n      }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      if (!isBlank(this.value) && customParent) {\n        arrayishRemove(customParent.refs, this.value, tagOrDom);\n      }\n    }\n\n    /**\n     * Create a new ref directive\n     * @param   { HTMLElement } dom - dom node having the ref attribute\n     * @param   { Tag } context - tag instance where the DOM node is located\n     * @param   { String } attrName - either 'ref' or 'data-ref'\n     * @param   { String } attrValue - value of the ref attribute\n     * @returns { RefExpr } a new RefExpr object\n     */\n  };function createRefDirective(dom, tag, attrName, attrValue) {\n    return create(RefExpr).init(dom, tag, attrName, attrValue);\n  }\n\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr.unmount) {\n        expr.unmount(true);\n      } else if (expr.tagName) {\n        expr.tag.unmount(true);\n      } else if (expr.unmount) {\n        expr.unmount();\n      }\n    });\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n      extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n\n      return this;\n    },\n    update: function update$$1() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (this.value && !this.current) {\n        // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n      } else if (!this.value && this.current) {\n        // remove\n        this.unmount();\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) {\n        update.call(this.tag, this.expressions);\n      }\n    },\n    unmount: function unmount() {\n      if (this.current) {\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n      }\n\n      unmountAll(this.expressions || []);\n    }\n\n    /**\n     * Create a new if directive\n     * @param   { HTMLElement } dom - if root dom node\n     * @param   { Tag } context - tag instance where the DOM node is located\n     * @param   { String } attr - if expression\n     * @returns { IFExpr } a new IfExpr object\n     */\n  };function createIfDirective(dom, tag, attr) {\n    return create(IfExpr).init(dom, tag, attr);\n  }\n\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Array } all the expressions found\n   */\n  function parseExpressions(root, mustIncludeRoot) {\n    var this$1 = this;\n\n    var expressions = [];\n\n    walkNodes(root, function (dom) {\n      var type = dom.nodeType;\n      var attr;\n      var tagImpl;\n\n      if (!mustIncludeRoot && dom === root) {\n        return;\n      }\n\n      // text node\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue)) {\n        expressions.push({ dom: dom, expr: dom.nodeValue });\n      }\n\n      if (type !== 1) {\n        return;\n      }\n\n      var isVirtual = dom.tagName === 'VIRTUAL';\n\n      // loop. each does it's own thing (for now)\n      if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n        if (isVirtual) {\n          setAttribute(dom, 'loopVirtual', true);\n        } // ignore here, handled in _each\n        expressions.push(_each(dom, this$1, attr));\n        return false;\n      }\n\n      // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n      if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n        expressions.push(createIfDirective(dom, this$1, attr));\n        return false;\n      }\n\n      if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(attr)) {\n          expressions.push({\n            isRtag: true,\n            expr: attr,\n            dom: dom,\n            attrs: [].slice.call(dom.attributes)\n          });\n\n          return false;\n        }\n      }\n\n      // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n      tagImpl = get(dom);\n\n      if (isVirtual) {\n        if (getAttribute(dom, 'virtualized')) {\n          dom.parentElement.removeChild(dom);\n        } // tag created, remove from dom\n        if (!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual')) // ok to create virtual tag\n          {\n            tagImpl = { tmpl: dom.outerHTML };\n          }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        var hasIsDirective = getAttribute(dom, IS_DIRECTIVE);\n        if (isVirtual && !hasIsDirective) {\n          // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttribute(dom, 'virtualized', true);\n          var tag = createTag({ tmpl: dom.outerHTML }, { root: dom, parent: this$1 }, dom.innerHTML);\n\n          expressions.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          if (hasIsDirective && isVirtual) {\n            warn(\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\");\n          }\n\n          expressions.push(initChild(tagImpl, {\n            root: dom,\n            parent: this$1\n          }, dom.innerHTML, this$1));\n          return false;\n        }\n      }\n\n      // attribute expressions\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) {\n          return;\n        }\n        expressions.push(expr);\n      }]);\n    });\n\n    return expressions;\n  }\n\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n\n    each(attrs, function (attr) {\n      if (!attr) {\n        return false;\n      }\n\n      var name = attr.name;\n      var bool = isBoolAttr(name);\n      var expr;\n\n      if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n        expr = createRefDirective(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = { dom: dom, expr: attr.value, attr: name, bool: bool };\n      }\n\n      fn(attr, expr);\n    });\n  }\n\n  /**\n   * Manage the mount state of a tag triggering also the observable events\n   * @this Tag\n   * @param { Boolean } value - ..of the isMounted flag\n   */\n  function setMountState(value) {\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n\n    define(this, 'isMounted', value);\n\n    if (!isAnonymous) {\n      if (value) {\n        this.trigger('mount');\n      } else {\n        this.trigger('unmount');\n        this.off('*');\n        this.__.wasCreated = false;\n      }\n    }\n  }\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  function componentMount(tag$$1, dom, expressions, opts) {\n    var __ = tag$$1.__;\n    var root = __.root;\n    root._tag = tag$$1; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n      if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) {\n        expr.tag = tag$$1;\n      }\n      attr.expr = expr;\n      __.instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    walkAttributes(__.impl.attrs, function (k, v) {\n      __.implAttrs.push({ name: k, value: v });\n    });\n    parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n      if (expr) {\n        expressions.push(expr);\n      } else {\n        setAttribute(root, attr.name, attr.value);\n      }\n    }]);\n\n    // initialiation\n    updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin(GLOBAL_MIXIN);\n\n    if (globalMixin && !__.skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          tag$$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (__.impl.fn) {\n      __.impl.fn.call(tag$$1, opts);\n    }\n\n    if (!__.skipAnonymous) {\n      tag$$1.trigger('before-mount');\n    }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) {\n      return expressions.push(e);\n    });\n\n    tag$$1.update(__.item);\n\n    if (!__.isAnonymous && !__.isInline) {\n      while (dom.firstChild) {\n        root.appendChild(dom.firstChild);\n      }\n    }\n\n    define(tag$$1, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!__.skipAnonymous && tag$$1.parent) {\n      var p = getImmediateCustomParent(tag$$1.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setMountState.call(tag$$1, true);\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setMountState.call(tag$$1, true);\n    }\n\n    tag$$1.__.wasCreated = true;\n\n    return tag$$1;\n  }\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  function tagUnmount(tag, mustKeepRoot, expressions) {\n    var __ = tag.__;\n    var root = __.root;\n    var tagIndex = __TAGS_CACHE.indexOf(tag);\n    var p = root.parentNode;\n\n    if (!__.skipAnonymous) {\n      tag.trigger('before-unmount');\n    }\n\n    // clear all attributes coming from the mounted tag\n    walkAttributes(__.impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX)) {\n        name = name.slice(ATTRS_PREFIX.length);\n      }\n\n      removeAttribute(root, name);\n    });\n\n    // remove all the event listeners\n    tag.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove tag instance from the global tags cache collection\n    if (tagIndex !== -1) {\n      __TAGS_CACHE.splice(tagIndex, 1);\n    }\n\n    // clean up the parent tags object\n    if (__.parent && !__.isAnonymous) {\n      var ptag = getImmediateCustomParent(__.parent);\n\n      if (__.isVirtual) {\n        Object.keys(tag.tags).forEach(function (tagName) {\n          return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]);\n        });\n      } else {\n        arrayishRemove(ptag.tags, __.tagName, tag);\n      }\n    }\n\n    // unmount all the virtual directives\n    if (tag.__.virts) {\n      each(tag.__.virts, function (v) {\n        if (v.parentNode) {\n          v.parentNode.removeChild(v);\n        }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(__.instAttrs, function (a) {\n      return a.expr && a.expr.unmount && a.expr.unmount();\n    });\n\n    // clear the tag html if it's necessary\n    if (mustKeepRoot) {\n      setInnerHTML(root, '');\n    }\n    // otherwise detach the root tag from the DOM\n    else if (p) {\n        p.removeChild(root);\n      }\n\n    // custom internal unmount function to avoid relying on the observable\n    if (__.onUnmount) {\n      __.onUnmount();\n    }\n\n    // weird fix for a weird edge case #2409 and #2436\n    // some users might use your software not as you've expected\n    // so I need to add these dirty hacks to mitigate unexpected issues\n    if (!tag.isMounted) {\n      setMountState.call(tag, true);\n    }\n\n    setMountState.call(tag, false);\n\n    delete root._tag;\n\n    return tag;\n  }\n\n  /**\n   * Tag creation factory function\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n  function createTag(impl, conf, innerHTML) {\n    if (impl === void 0) impl = {};\n    if (conf === void 0) conf = {};\n\n    var tag = conf.context || {};\n    var opts = conf.opts || {};\n    var parent = conf.parent;\n    var isLoop = conf.isLoop;\n    var isAnonymous = !!conf.isAnonymous;\n    var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n    var item = conf.item;\n    // available only for the looped nodes\n    var index = conf.index;\n    // All attributes on the Tag when it's first parsed\n    var instAttrs = [];\n    // expressions on this type of Tag\n    var implAttrs = [];\n    var tmpl = impl.tmpl;\n    var expressions = [];\n    var root = conf.root;\n    var tagName = conf.tagName || getName(root);\n    var isVirtual = tagName === 'virtual';\n    var isInline = !isVirtual && !tmpl;\n    var dom;\n\n    if (isInline || isLoop && isAnonymous) {\n      dom = root;\n    } else {\n      if (!isVirtual) {\n        root.innerHTML = '';\n      }\n      dom = mkdom(tmpl, innerHTML, isSvg(root));\n    }\n\n    // make this tag observable\n    if (!skipAnonymous) {\n      observable(tag);\n    }\n\n    // only call unmount if we have a valid __TAG_IMPL (has name property)\n    if (impl.name && root._tag) {\n      root._tag.unmount(true);\n    }\n\n    define(tag, '__', {\n      impl: impl,\n      root: root,\n      skipAnonymous: skipAnonymous,\n      implAttrs: implAttrs,\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      isInline: isInline,\n      item: item,\n      parent: parent,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      wasCreated: false,\n      tail: null,\n      head: null\n    });\n\n    // tag protected properties\n    return [['isMounted', false],\n    // create a unique id to this tag\n    // it could be handy to use it also to improve the virtual dom rendering speed\n    ['_riot_id', uid()], ['root', root], ['opts', opts, { writable: true, enumerable: true }], ['parent', parent || null],\n    // protect the \"tags\" and \"refs\" property from being overridden\n    ['tags', {}], ['refs', {}], ['update', function (data) {\n      return componentUpdate(tag, data, expressions);\n    }], ['mixin', function () {\n      var mixins = [],\n          len = arguments.length;\n      while (len--) {\n        mixins[len] = arguments[len];\n      }return componentMixin.apply(void 0, [tag].concat(mixins));\n    }], ['mount', function () {\n      return componentMount(tag, dom, expressions, opts);\n    }], ['unmount', function (mustKeepRoot) {\n      return tagUnmount(tag, mustKeepRoot, expressions);\n    }]].reduce(function (acc, ref) {\n      var key = ref[0];\n      var value = ref[1];\n      var opts = ref[2];\n\n      define(tag, key, value, opts);\n      return acc;\n    }, extend(tag, item));\n  }\n\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n  function mount$1(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName];\n    var implClass = __TAG_IMPL[tagName].class;\n    var context = ctx || (implClass ? create(implClass.prototype) : {});\n    // cache the inner HTML to fix #855\n    var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n    var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n    var tag;\n\n    if (impl && root) {\n      tag = createTag(impl, conf, innerHTML);\n    }\n\n    if (tag && tag.mount) {\n      tag.mount(true);\n      // add this tag to the virtualDom variable\n      if (!contains(__TAGS_CACHE, tag)) {\n        __TAGS_CACHE.push(tag);\n      }\n    }\n\n    return tag;\n  }\n\n  var tags = /*#__PURE__*/Object.freeze({\n    arrayishAdd: arrayishAdd,\n    getTagName: getName,\n    inheritParentProps: inheritParentProps,\n    mountTo: mount$1,\n    selectTags: query,\n    arrayishRemove: arrayishRemove,\n    getTag: get,\n    initChildTag: initChild,\n    moveChildTag: moveChild,\n    makeReplaceVirtual: makeReplaceVirtual,\n    getImmediateCustomParentTag: getImmediateCustomParent,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    unmountAll: unmountAll,\n    createIfDirective: createIfDirective,\n    createRefDirective: createRefDirective\n  });\n\n  /**\n   * Riot public api\n   */\n  var settings$1 = settings;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  };\n\n  // export the core props/methods\n  var Tag$1 = Tag;\n  var tag$1 = tag;\n  var tag2$1 = tag2;\n  var mount$2 = mount;\n  var mixin$1 = mixin;\n  var update$2 = update$1;\n  var unregister$1 = unregister;\n  var version$1 = version;\n  var observable$1 = observable;\n\n  var riot$1 = extend({}, core, {\n    observable: observable,\n    settings: settings$1,\n    util: util\n  });\n\n  exports.settings = settings$1;\n  exports.util = util;\n  exports.Tag = Tag$1;\n  exports.tag = tag$1;\n  exports.tag2 = tag2$1;\n  exports.mount = mount$2;\n  exports.mixin = mixin$1;\n  exports.update = update$2;\n  exports.unregister = unregister$1;\n  exports.version = version$1;\n  exports.observable = observable$1;\n  exports.default = riot$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n\n//# sourceURL=webpack:///./node_modules/riot/riot.js?");

/***/ }),

/***/ "./node_modules/textile-js/lib/textile.js":
/*!************************************************!*\
  !*** ./node_modules/textile-js/lib/textile.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(undefined, function () {\n\treturn (/******/function (modules) {\n\t\t\t// webpackBootstrap\n\t\t\t/******/ // The module cache\n\t\t\t/******/var installedModules = {};\n\t\t\t/******/\n\t\t\t/******/ // The require function\n\t\t\t/******/function __webpack_require__(moduleId) {\n\t\t\t\t/******/\n\t\t\t\t/******/ // Check if module is in cache\n\t\t\t\t/******/if (installedModules[moduleId])\n\t\t\t\t\t/******/return installedModules[moduleId].exports;\n\t\t\t\t/******/\n\t\t\t\t/******/ // Create a new module (and put it into the cache)\n\t\t\t\t/******/var module = installedModules[moduleId] = {\n\t\t\t\t\t/******/exports: {},\n\t\t\t\t\t/******/id: moduleId,\n\t\t\t\t\t/******/loaded: false\n\t\t\t\t\t/******/ };\n\t\t\t\t/******/\n\t\t\t\t/******/ // Execute the module function\n\t\t\t\t/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t\t\t/******/\n\t\t\t\t/******/ // Flag the module as loaded\n\t\t\t\t/******/module.loaded = true;\n\t\t\t\t/******/\n\t\t\t\t/******/ // Return the exports of the module\n\t\t\t\t/******/return module.exports;\n\t\t\t\t/******/\n\t\t\t}\n\t\t\t/******/\n\t\t\t/******/\n\t\t\t/******/ // expose the modules object (__webpack_modules__)\n\t\t\t/******/__webpack_require__.m = modules;\n\t\t\t/******/\n\t\t\t/******/ // expose the module cache\n\t\t\t/******/__webpack_require__.c = installedModules;\n\t\t\t/******/\n\t\t\t/******/ // __webpack_public_path__\n\t\t\t/******/__webpack_require__.p = \"\";\n\t\t\t/******/\n\t\t\t/******/ // Load entry module and return exports\n\t\t\t/******/return __webpack_require__(0);\n\t\t\t/******/\n\t\t}(\n\t\t/************************************************************************/\n\t\t/******/[\n\t\t/* 0 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/*\n   ** Textile parser for JavaScript\n   **\n   ** Copyright (c) 2012 Borgar orsteinsson (MIT License).\n   **\n   */\n\n\t\t\tvar merge = __webpack_require__(1);\n\n\t\t\tvar _require = __webpack_require__(2),\n\t\t\t    toHTML = _require.toHTML;\n\n\t\t\tvar _require2 = __webpack_require__(6),\n\t\t\t    parseFlow = _require2.parseFlow;\n\n\t\t\tvar _require3 = __webpack_require__(3),\n\t\t\t    parseHtml = _require3.parseHtml;\n\n\t\t\tfunction textile(txt, opt) {\n\t\t\t\t// get a throw-away copy of options\n\t\t\t\topt = merge(merge({}, textile.defaults), opt || {});\n\t\t\t\t// run the converter\n\t\t\t\treturn parseFlow(txt, opt).map(toHTML).join('');\n\t\t\t};\n\t\t\tmodule.exports = textile;\n\n\t\t\t// options\n\t\t\ttextile.defaults = {\n\t\t\t\t// single-line linebreaks are converted to <br> by default\n\t\t\t\t'breaks': true\n\t\t\t};\n\t\t\ttextile.setOptions = textile.setoptions = function (opt) {\n\t\t\t\tmerge(textile.defaults, opt);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\ttextile.parse = textile.convert = textile;\n\t\t\ttextile.html_parser = parseHtml;\n\n\t\t\ttextile.jsonml = function (txt, opt) {\n\t\t\t\t// get a throw-away copy of options\n\t\t\t\topt = merge(merge({}, textile.defaults), opt || {});\n\t\t\t\t// parse and return tree\n\t\t\t\treturn ['html'].concat(parseFlow(txt, opt));\n\t\t\t};\n\t\t\ttextile.serialize = toHTML;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 1 */\n\t\t/***/function (module, exports) {\n\n\t\t\t\"use strict\";\n\n\t\t\t// merge object b properties into object a\n\n\t\t\tmodule.exports = function merge(a, b) {\n\t\t\t\tif (b) {\n\t\t\t\t\tfor (var k in b) {\n\t\t\t\t\t\ta[k] = b[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 2 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\tvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n\t\t\t\treturn typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t} : function (obj) {\n\t\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t};\n\n\t\t\t/*\n   ** JSONML helper methods - http://www.jsonml.org/\n   **\n   ** This provides the `JSONML` object, which contains helper\n   ** methods for rendering JSONML to HTML.\n   **\n   ** Note that the tag ! is taken to mean comment, this is however\n   ** not specified in the JSONML spec.\n   */\n\n\t\t\tvar singletons = __webpack_require__(3).singletons;\n\n\t\t\t// drop or add tab levels to JsonML tree\n\t\t\tfunction reIndent(ml, shiftBy) {\n\t\t\t\t// a bit obsessive, but there we are...\n\t\t\t\tif (!shiftBy) {\n\t\t\t\t\treturn ml;\n\t\t\t\t}\n\t\t\t\treturn ml.map(function (s) {\n\t\t\t\t\tif (/^\\n\\t+/.test(s)) {\n\t\t\t\t\t\tif (shiftBy < 0) {\n\t\t\t\t\t\t\ts = s.slice(0, shiftBy);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (var i = 0; i < shiftBy; i++) {\n\t\t\t\t\t\t\t\ts += '\\t';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Array.isArray(s)) {\n\t\t\t\t\t\treturn reIndent(s, shiftBy);\n\t\t\t\t\t}\n\t\t\t\t\treturn s;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction escape(text, escapeQuotes) {\n\t\t\t\treturn text.replace(/&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, escapeQuotes ? '&quot;' : '\"').replace(/'/g, escapeQuotes ? '&#39;' : \"'\");\n\t\t\t}\n\n\t\t\tfunction toHTML(jsonml) {\n\t\t\t\tjsonml = jsonml.concat();\n\n\t\t\t\t// basic case\n\t\t\t\tif (typeof jsonml === 'string') {\n\t\t\t\t\treturn escape(jsonml);\n\t\t\t\t}\n\n\t\t\t\tvar tag = jsonml.shift();\n\t\t\t\tvar attributes = {};\n\t\t\t\tvar tagAttrs = '';\n\t\t\t\tvar content = [];\n\n\t\t\t\tif (jsonml.length && _typeof(jsonml[0]) === 'object' && !Array.isArray(jsonml[0])) {\n\t\t\t\t\tattributes = jsonml.shift();\n\t\t\t\t}\n\n\t\t\t\twhile (jsonml.length) {\n\t\t\t\t\tcontent.push(toHTML(jsonml.shift()));\n\t\t\t\t}\n\n\t\t\t\tfor (var a in attributes) {\n\t\t\t\t\ttagAttrs += attributes[a] == null ? ' ' + a : ' ' + a + '=\"' + escape(String(attributes[a]), true) + '\"';\n\t\t\t\t}\n\n\t\t\t\t// be careful about adding whitespace here for inline elements\n\t\t\t\tif (tag === '!') {\n\t\t\t\t\treturn '<!--' + content.join('') + '-->';\n\t\t\t\t} else if (tag in singletons || tag.indexOf(':') > -1 && !content.length) {\n\t\t\t\t\treturn '<' + tag + tagAttrs + ' />';\n\t\t\t\t} else {\n\t\t\t\t\treturn '<' + tag + tagAttrs + '>' + content.join('') + '</' + tag + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodule.exports = {\n\t\t\t\treIndent: reIndent,\n\t\t\t\ttoHTML: toHTML,\n\t\t\t\tescape: escape\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 3 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\tvar re = __webpack_require__(4);\n\t\t\tvar ribbon = __webpack_require__(5);\n\n\t\t\tre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\n\t\t\tre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\n\t\t\tvar reAttr = re.compile(/^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/);\n\t\t\tvar reComment = re.compile(/^<!--(.+?)-->/, 's');\n\t\t\tvar reEndTag = re.compile(/^<\\/([:html_id:])([^>]*)>/);\n\t\t\tvar reTag = re.compile(/^<([:html_id:])((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\n\t\t\tvar reHtmlTagBlock = re.compile(/^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\n\n\t\t\tvar singletons = {\n\t\t\t\tarea: 1,\n\t\t\t\tbase: 1,\n\t\t\t\tbr: 1,\n\t\t\t\tcol: 1,\n\t\t\t\tembed: 1,\n\t\t\t\thr: 1,\n\t\t\t\timg: 1,\n\t\t\t\tinput: 1,\n\t\t\t\tlink: 1,\n\t\t\t\tmeta: 1,\n\t\t\t\toption: 1,\n\t\t\t\tparam: 1,\n\t\t\t\twbr: 1\n\t\t\t};\n\n\t\t\tfunction allowAll() {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction testComment(src) {\n\t\t\t\treturn reComment.exec(src);\n\t\t\t}\n\n\t\t\tfunction testOpenTagBlock(src) {\n\t\t\t\treturn reHtmlTagBlock.exec(src);\n\t\t\t}\n\n\t\t\tfunction testOpenTag(src) {\n\t\t\t\treturn reTag.exec(src);\n\t\t\t}\n\n\t\t\tfunction testCloseTag(src) {\n\t\t\t\treturn reEndTag.exec(src);\n\t\t\t}\n\n\t\t\tfunction parseHtmlAttr(attrSrc) {\n\t\t\t\t// parse ATTR and add to element\n\t\t\t\tvar attr = {};\n\t\t\t\tvar m = void 0;\n\t\t\t\twhile (m = reAttr.exec(attrSrc)) {\n\t\t\t\t\tattr[m[1]] = typeof m[2] === 'string' ? m[2].replace(/^([\"'])(.*)\\1$/, '$2') : null;\n\t\t\t\t\tattrSrc = attrSrc.slice(m[0].length);\n\t\t\t\t}\n\t\t\t\treturn attr;\n\t\t\t}\n\n\t\t\tvar OPEN = 'OPEN';\n\t\t\tvar CLOSE = 'CLOSE';\n\t\t\tvar SINGLE = 'SINGLE';\n\t\t\tvar TEXT = 'TEXT';\n\t\t\tvar COMMENT = 'COMMENT';\n\t\t\tvar WS = 'WS';\n\n\t\t\tfunction tokenize(src, whitelistTags, lazy) {\n\t\t\t\tvar tokens = [];\n\t\t\t\tvar textMode = false;\n\t\t\t\tvar oktag = whitelistTags ? function (tag) {\n\t\t\t\t\treturn tag in whitelistTags;\n\t\t\t\t} : allowAll;\n\t\t\t\tvar oktag_ = oktag;\n\t\t\t\tvar nesting = {};\n\t\t\t\tvar nestCount = 0;\n\t\t\t\tvar m = void 0;\n\n\t\t\t\tsrc = ribbon(String(src));\n\n\t\t\t\tdo {\n\t\t\t\t\t// comment\n\t\t\t\t\tif ((m = testComment(src)) && oktag('!')) {\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\ttype: COMMENT,\n\t\t\t\t\t\t\tdata: m[1],\n\t\t\t\t\t\t\tpos: src.index(),\n\t\t\t\t\t\t\tsrc: m[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// end tag\n\t\t\t\t\telse if ((m = testCloseTag(src)) && oktag(m[1])) {\n\t\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\t\ttype: CLOSE,\n\t\t\t\t\t\t\t\ttag: m[1],\n\t\t\t\t\t\t\t\tpos: src.index(),\n\t\t\t\t\t\t\t\tsrc: m[0]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t\t\tnesting[token.tag]--;\n\t\t\t\t\t\t\tnestCount--;\n\t\t\t\t\t\t\t// console.log( '/' + token.tag, nestCount, nesting );\n\t\t\t\t\t\t\tif (lazy && (!nestCount || !nesting[token.tag] < 0 || isNaN(nesting[token.tag]))) {\n\t\t\t\t\t\t\t\treturn tokens;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if parse is in text mode then that ends here\n\t\t\t\t\t\t\tif (textMode) {\n\t\t\t\t\t\t\t\ttextMode = null;\n\t\t\t\t\t\t\t\toktag = oktag_;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// open/void tag\n\t\t\t\t\t\telse if ((m = testOpenTag(src)) && oktag(m[1])) {\n\t\t\t\t\t\t\t\tvar _token = {\n\t\t\t\t\t\t\t\t\ttype: m[3] || m[1] in singletons ? SINGLE : OPEN,\n\t\t\t\t\t\t\t\t\ttag: m[1],\n\t\t\t\t\t\t\t\t\tpos: src.index(),\n\t\t\t\t\t\t\t\t\tsrc: m[0]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\t\t\t_token.attr = parseHtmlAttr(m[2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// some elements can move parser into \"text\" mode\n\t\t\t\t\t\t\t\tif (m[1] === 'script' || m[1] === 'code' || m[1] === 'style') {\n\t\t\t\t\t\t\t\t\ttextMode = _token.tag;\n\t\t\t\t\t\t\t\t\toktag = function oktag(tag) {\n\t\t\t\t\t\t\t\t\t\treturn tag === textMode;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_token.type === OPEN) {\n\t\t\t\t\t\t\t\t\tnestCount++;\n\t\t\t\t\t\t\t\t\tnesting[_token.tag] = (nesting[_token.tag] || 0) + 1;\n\t\t\t\t\t\t\t\t\t// console.log( token.tag, nestCount, nesting );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttokens.push(_token);\n\t\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// text content\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// no match, move by all \"uninteresting\" chars\n\t\t\t\t\t\t\t\t\tm = /([^<]+|[^\\0])/.exec(src);\n\t\t\t\t\t\t\t\t\tif (m) {\n\t\t\t\t\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\t\t\t\t\ttype: TEXT,\n\t\t\t\t\t\t\t\t\t\t\tdata: m[0],\n\t\t\t\t\t\t\t\t\t\t\tpos: src.index(),\n\t\t\t\t\t\t\t\t\t\t\tsrc: m[0]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsrc.advance(m ? m[0].length || 1 : 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t} while (src.valueOf());\n\n\t\t\t\treturn tokens;\n\t\t\t}\n\n\t\t\t// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n\t\t\t// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\n\t\t\tfunction parse(tokens, lazy) {\n\t\t\t\tvar root = [];\n\t\t\t\tvar stack = [];\n\t\t\t\tvar curr = root;\n\t\t\t\tvar token = void 0;\n\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.type === COMMENT) {\n\t\t\t\t\t\tcurr.push(['!', token.data]);\n\t\t\t\t\t} else if (token.type === TEXT || token.type === WS) {\n\t\t\t\t\t\tcurr.push(token.data);\n\t\t\t\t\t} else if (token.type === SINGLE) {\n\t\t\t\t\t\tcurr.push(token.attr ? [token.tag, token.attr] : [token.tag]);\n\t\t\t\t\t} else if (token.type === OPEN) {\n\t\t\t\t\t\t// TODO: some things auto close other things: <td>, <li>, <p>, <table>\n\t\t\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission\n\t\t\t\t\t\tvar elm = token.attr ? [token.tag, token.attr] : [token.tag];\n\t\t\t\t\t\tcurr.push(elm);\n\t\t\t\t\t\tstack.push(elm);\n\t\t\t\t\t\tcurr = elm;\n\t\t\t\t\t} else if (token.type === CLOSE) {\n\t\t\t\t\t\tif (stack.length) {\n\t\t\t\t\t\t\tfor (var _i = stack.length - 1; _i >= 0; _i--) {\n\t\t\t\t\t\t\t\tvar head = stack[_i];\n\t\t\t\t\t\t\t\tif (head[0] === token.tag) {\n\t\t\t\t\t\t\t\t\tstack.splice(_i);\n\t\t\t\t\t\t\t\t\tcurr = stack[stack.length - 1] || root;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!stack.length && lazy) {\n\t\t\t\t\t\t\troot.sourceLength = token.pos + token.src.length;\n\t\t\t\t\t\t\treturn root;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\troot.sourceLength = token ? token.pos + token.src.length : 0;\n\t\t\t\treturn root;\n\t\t\t}\n\n\t\t\tmodule.exports = {\n\t\t\t\tsingletons: singletons,\n\t\t\t\ttokenize: tokenize,\n\t\t\t\tparseHtml: parse,\n\t\t\t\tparseHtmlAttr: parseHtmlAttr,\n\t\t\t\ttestCloseTag: testCloseTag,\n\t\t\t\ttestOpenTagBlock: testOpenTagBlock,\n\t\t\t\ttestOpenTag: testOpenTag,\n\t\t\t\ttestComment: testComment\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 4 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\t/*\n   ** Regular Expression helper methods\n   **\n   ** This provides the `re` object, which contains several helper\n   ** methods for working with big regular expressions (soup).\n   **\n   */\n\n\t\t\tvar _cache = {};\n\n\t\t\tvar re = module.exports = {\n\n\t\t\t\tpattern: {\n\t\t\t\t\t'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n\t\t\t\t\t'space': '\\\\s'\n\t\t\t\t},\n\n\t\t\t\tescape: function escape(src) {\n\t\t\t\t\treturn src.replace(/[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.,\\\\\\^\\$\\|#\\s]/g, '\\\\$&');\n\t\t\t\t},\n\n\t\t\t\tcollapse: function collapse(src) {\n\t\t\t\t\treturn src.replace(/(?:#.*?(?:\\n|$))/g, '').replace(/\\s+/g, '');\n\t\t\t\t},\n\n\t\t\t\texpandPatterns: function expandPatterns(src) {\n\t\t\t\t\t// TODO: provide escape for patterns: \\[:pattern:] ?\n\t\t\t\t\treturn src.replace(/\\[:\\s*(\\w+)\\s*:\\]/g, function (m, k) {\n\t\t\t\t\t\tvar ex = re.pattern[k];\n\t\t\t\t\t\tif (ex) {\n\t\t\t\t\t\t\treturn re.expandPatterns(ex);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Pattern ' + m + ' not found in ' + src);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\tisRegExp: function isRegExp(r) {\n\t\t\t\t\treturn Object.prototype.toString.call(r) === '[object RegExp]';\n\t\t\t\t},\n\n\t\t\t\tcompile: function compile(src, flags) {\n\t\t\t\t\tif (re.isRegExp(src)) {\n\t\t\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\t\t\t// no flags arg provided, use the RegExp one\n\t\t\t\t\t\t\tflags = (src.global ? 'g' : '') + (src.ignoreCase ? 'i' : '') + (src.multiline ? 'm' : '');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc = src.source;\n\t\t\t\t\t}\n\t\t\t\t\t// don't do the same thing twice\n\t\t\t\t\tvar ckey = src + (flags || '');\n\t\t\t\t\tif (ckey in _cache) {\n\t\t\t\t\t\treturn _cache[ckey];\n\t\t\t\t\t}\n\t\t\t\t\t// allow classes\n\t\t\t\t\tvar rx = re.expandPatterns(src);\n\t\t\t\t\t// allow verbose expressions\n\t\t\t\t\tif (flags && /x/.test(flags)) {\n\t\t\t\t\t\trx = re.collapse(rx);\n\t\t\t\t\t}\n\t\t\t\t\t// allow dotall expressions\n\t\t\t\t\tif (flags && /s/.test(flags)) {\n\t\t\t\t\t\trx = rx.replace(/([^\\\\])\\./g, '$1[^\\\\0]');\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n\t\t\t\t\t// clean flags and output new regexp\n\t\t\t\t\tflags = (flags || '').replace(/[^gim]/g, '');\n\t\t\t\t\treturn _cache[ckey] = new RegExp(rx, flags);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 5 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function ribbon(feed) {\n\t\t\t\tvar org = String(feed);\n\t\t\t\tvar slot = void 0;\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar self = {\n\n\t\t\t\t\tindex: function index() {\n\t\t\t\t\t\treturn pos;\n\t\t\t\t\t},\n\n\t\t\t\t\tsave: function save() {\n\t\t\t\t\t\tslot = pos;\n\t\t\t\t\t\treturn self;\n\t\t\t\t\t},\n\n\t\t\t\t\tload: function load() {\n\t\t\t\t\t\tpos = slot;\n\t\t\t\t\t\tfeed = org.slice(pos);\n\t\t\t\t\t\treturn self;\n\t\t\t\t\t},\n\n\t\t\t\t\tadvance: function advance(n) {\n\t\t\t\t\t\tpos += typeof n === 'string' ? n.length : n;\n\t\t\t\t\t\tfeed = org.slice(pos);\n\t\t\t\t\t\treturn feed;\n\t\t\t\t\t},\n\n\t\t\t\t\tskipWS: function skipWS() {\n\t\t\t\t\t\tvar ws = /^\\s+/.exec(feed);\n\t\t\t\t\t\tif (ws) {\n\t\t\t\t\t\t\tpos += ws[0].length;\n\t\t\t\t\t\t\tfeed = org.slice(pos);\n\t\t\t\t\t\t\treturn ws[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\n\t\t\t\t\tlookbehind: function lookbehind(nchars) {\n\t\t\t\t\t\tnchars = nchars == null ? 1 : nchars;\n\t\t\t\t\t\treturn org.slice(pos - nchars, pos);\n\t\t\t\t\t},\n\n\t\t\t\t\tstartsWith: function startsWith(s) {\n\t\t\t\t\t\treturn feed.substring(0, s.length) === s;\n\t\t\t\t\t},\n\n\t\t\t\t\tslice: function slice(a, b) {\n\t\t\t\t\t\treturn b != null ? feed.slice(a, b) : feed.slice(a);\n\t\t\t\t\t},\n\n\t\t\t\t\tvalueOf: function valueOf() {\n\t\t\t\t\t\treturn feed;\n\t\t\t\t\t},\n\n\t\t\t\t\ttoString: function toString() {\n\t\t\t\t\t\treturn feed;\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\treturn self;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 6 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/*\n   ** textile flow content parser\n   */\n\n\t\t\tvar builder = __webpack_require__(7);\n\t\t\tvar ribbon = __webpack_require__(5);\n\t\t\tvar re = __webpack_require__(4);\n\t\t\tvar fixLinks = __webpack_require__(8);\n\n\t\t\tvar _require = __webpack_require__(3),\n\t\t\t    parseHtml = _require.parseHtml,\n\t\t\t    tokenize = _require.tokenize,\n\t\t\t    parseHtmlAttr = _require.parseHtmlAttr,\n\t\t\t    singletons = _require.singletons,\n\t\t\t    testComment = _require.testComment,\n\t\t\t    testOpenTagBlock = _require.testOpenTagBlock;\n\n\t\t\tvar _require2 = __webpack_require__(9),\n\t\t\t    parsePhrase = _require2.parsePhrase;\n\n\t\t\tvar _require3 = __webpack_require__(10),\n\t\t\t    copyAttr = _require3.copyAttr,\n\t\t\t    parseAttr = _require3.parseAttr;\n\n\t\t\tvar _require4 = __webpack_require__(13),\n\t\t\t    testList = _require4.testList,\n\t\t\t    parseList = _require4.parseList;\n\n\t\t\tvar _require5 = __webpack_require__(14),\n\t\t\t    testDefList = _require5.testDefList,\n\t\t\t    parseDefList = _require5.parseDefList;\n\n\t\t\tvar _require6 = __webpack_require__(15),\n\t\t\t    testTable = _require6.testTable,\n\t\t\t    parseTable = _require6.parseTable;\n\n\t\t\tvar _require7 = __webpack_require__(12),\n\t\t\t    txblocks = _require7.txblocks,\n\t\t\t    txlisthd = _require7.txlisthd,\n\t\t\t    txattr = _require7.txattr;\n\n\t\t\tre.pattern.txblocks = txblocks;\n\t\t\tre.pattern.txlisthd = txlisthd;\n\t\t\tre.pattern.txattr = txattr;\n\n\t\t\t// HTML tags allowed in the document (root) level that trigger HTML parsing\n\t\t\tvar allowedBlocktags = {\n\t\t\t\t'p': 0,\n\t\t\t\t'hr': 0,\n\t\t\t\t'ul': 1,\n\t\t\t\t'ol': 0,\n\t\t\t\t'li': 0,\n\t\t\t\t'div': 1,\n\t\t\t\t'pre': 0,\n\t\t\t\t'object': 1,\n\t\t\t\t'script': 0,\n\t\t\t\t'noscript': 0,\n\t\t\t\t'blockquote': 1,\n\t\t\t\t'notextile': 1\n\t\t\t};\n\n\t\t\tvar reBlock = re.compile(/^([:txblocks:])/);\n\t\t\tvar reBlockNormal = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's');\n\t\t\tvar reBlockExtended = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\t\t\tvar reBlockNormalPre = re.compile(/^(.*?)($|\\r?\\n(?:\\s*\\n|$)+)/, 's');\n\t\t\tvar reBlockExtendedPre = re.compile(/^(.*?)($|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\n\t\t\tvar reRuler = /^(\\-\\-\\-+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\n\t\t\tvar reLinkRef = re.compile(/^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/);\n\t\t\tvar reFootnoteDef = /^fn\\d+$/;\n\n\t\t\tvar hasOwn = Object.prototype.hasOwnProperty;\n\t\t\tfunction extend(target) {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\t\targs[_key - 1] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 1; i < args.length; i++) {\n\t\t\t\t\tvar src = args[i];\n\t\t\t\t\tif (src != null) {\n\t\t\t\t\t\tfor (var nextKey in src) {\n\t\t\t\t\t\t\tif (hasOwn.call(src, nextKey)) {\n\t\t\t\t\t\t\t\ttarget[nextKey] = src[nextKey];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tfunction paragraph(s, tag, pba, linebreak, options) {\n\t\t\t\ttag = tag || 'p';\n\t\t\t\tvar out = [];\n\t\t\t\ts.split(/(?:\\r?\\n){2,}/).forEach(function (bit, i) {\n\t\t\t\t\tif (tag === 'p' && /^\\s/.test(bit)) {\n\t\t\t\t\t\t// no-paragraphs\n\t\t\t\t\t\tbit = bit.replace(/\\r?\\n[\\t ]/g, ' ').trim();\n\t\t\t\t\t\tout = out.concat(parsePhrase(bit, options));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (linebreak && i) {\n\t\t\t\t\t\t\tout.push(linebreak);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.push(pba ? [tag, pba].concat(parsePhrase(bit, options)) : [tag].concat(parsePhrase(bit, options)));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t};\n\n\t\t\tfunction parseFlow(src, options) {\n\t\t\t\tvar list = builder();\n\n\t\t\t\tvar linkRefs = void 0;\n\t\t\t\tvar m = void 0;\n\n\t\t\t\tsrc = ribbon(src.replace(/^( *\\r?\\n)+/, ''));\n\n\t\t\t\t// loop\n\t\t\t\twhile (src.valueOf()) {\n\t\t\t\t\tsrc.save();\n\n\t\t\t\t\t// link_ref -- this goes first because it shouldn't trigger a linebreak\n\t\t\t\t\tif (m = reLinkRef.exec(src)) {\n\t\t\t\t\t\tif (!linkRefs) {\n\t\t\t\t\t\t\tlinkRefs = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlinkRefs[m[1]] = m[2];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add linebreak\n\t\t\t\t\tlist.linebreak();\n\n\t\t\t\t\t// named block\n\t\t\t\t\tif (m = reBlock.exec(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tvar blockType = m[0];\n\t\t\t\t\t\tvar pba = parseAttr(src, blockType);\n\n\t\t\t\t\t\tif (pba) {\n\t\t\t\t\t\t\tsrc.advance(pba[0]);\n\t\t\t\t\t\t\tpba = pba[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m = /^\\.(\\.?)(?:\\s|(?=:))/.exec(src)) {\n\t\t\t\t\t\t\t// FIXME: this whole copyAttr seems rather strange?\n\t\t\t\t\t\t\t// slurp rest of block\n\t\t\t\t\t\t\tvar extended = !!m[1];\n\t\t\t\t\t\t\tvar reBlockGlob = extended ? reBlockExtended : reBlockNormal;\n\t\t\t\t\t\t\tif (blockType === 'bc' || blockType === 'pre') {\n\t\t\t\t\t\t\t\treBlockGlob = extended ? reBlockExtendedPre : reBlockNormalPre;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm = reBlockGlob.exec(src.advance(m[0]));\n\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\t// bq | bc | notextile | pre | h# | fn# | p | ###\n\t\t\t\t\t\t\tif (blockType === 'bq') {\n\t\t\t\t\t\t\t\tvar inner = m[1];\n\t\t\t\t\t\t\t\tif (m = /^:(\\S+)\\s+/.exec(inner)) {\n\t\t\t\t\t\t\t\t\tif (!pba) {\n\t\t\t\t\t\t\t\t\t\tpba = {};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpba.cite = m[1];\n\t\t\t\t\t\t\t\t\tinner = inner.slice(m[0].length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n\t\t\t\t\t\t\t\tvar par = paragraph(inner, 'p', copyAttr(pba, { 'cite': 1, 'id': 1 }), '\\n', options);\n\t\t\t\t\t\t\t\tlist.add(['blockquote', pba, '\\n'].concat(par).concat(['\\n']));\n\t\t\t\t\t\t\t} else if (blockType === 'bc') {\n\t\t\t\t\t\t\t\tvar subPba = pba ? copyAttr(pba, { 'id': 1 }) : null;\n\t\t\t\t\t\t\t\tlist.add(['pre', pba, subPba ? ['code', subPba, m[1]] : ['code', m[1]]]);\n\t\t\t\t\t\t\t} else if (blockType === 'notextile') {\n\t\t\t\t\t\t\t\tlist.merge(parseHtml(tokenize(m[1])));\n\t\t\t\t\t\t\t} else if (blockType === '###') {\n\t\t\t\t\t\t\t\t// ignore the insides\n\t\t\t\t\t\t\t} else if (blockType === 'pre') {\n\t\t\t\t\t\t\t\t// I disagree with RedCloth, but agree with PHP here:\n\t\t\t\t\t\t\t\t// \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n\t\t\t\t\t\t\t\t// ...which seems like the whole point of having an extended pre block?\n\t\t\t\t\t\t\t\tlist.add(['pre', pba, m[1]]);\n\t\t\t\t\t\t\t} else if (reFootnoteDef.test(blockType)) {\n\t\t\t\t\t\t\t\t// footnote\n\t\t\t\t\t\t\t\t// Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n\t\t\t\t\t\t\t\tvar fnid = blockType.replace(/\\D+/g, '');\n\t\t\t\t\t\t\t\tif (!pba) {\n\t\t\t\t\t\t\t\t\tpba = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpba.class = (pba['class'] ? pba['class'] + ' ' : '') + 'footnote';\n\t\t\t\t\t\t\t\tpba.id = 'fn' + fnid;\n\t\t\t\t\t\t\t\tlist.add(['p', pba, ['a', { 'href': '#fnr' + fnid }, ['sup', fnid]], ' '].concat(parsePhrase(m[1], options)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// heading | paragraph\n\t\t\t\t\t\t\t\tlist.merge(paragraph(m[1], blockType, pba, '\\n', options));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsrc.load();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// HTML comment\n\t\t\t\t\tif (m = testComment(src)) {\n\t\t\t\t\t\tsrc.advance(m[0] + (/(?:\\s*\\n+)+/.exec(src) || [])[0]);\n\t\t\t\t\t\tlist.add(['!', m[1]]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// block HTML\n\t\t\t\t\tif (m = testOpenTagBlock(src)) {\n\t\t\t\t\t\tvar tag = m[1];\n\n\t\t\t\t\t\t// Is block tag? ...\n\t\t\t\t\t\tif (tag in allowedBlocktags) {\n\t\t\t\t\t\t\tif (m[3] || tag in singletons) {\n\t\t\t\t\t\t\t\t// single?\n\t\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\t\tif (/^\\s*(\\n|$)/.test(src)) {\n\t\t\t\t\t\t\t\t\tvar elm = [tag];\n\t\t\t\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\t\t\t\telm.push(parseHtmlAttr(m[2]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlist.add(elm);\n\t\t\t\t\t\t\t\t\tsrc.skipWS();\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (tag === 'pre') {\n\t\t\t\t\t\t\t\tvar t = tokenize(src, { 'pre': 1, 'code': 1 }, tag);\n\t\t\t\t\t\t\t\tvar p = parseHtml(t, true);\n\t\t\t\t\t\t\t\tsrc.load().advance(p.sourceLength);\n\t\t\t\t\t\t\t\tif (/^\\s*(\\n|$)/.test(src)) {\n\t\t\t\t\t\t\t\t\tlist.merge(p);\n\t\t\t\t\t\t\t\t\tsrc.skipWS(); // skip tailing whitespace\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (tag === 'notextile') {\n\t\t\t\t\t\t\t\t// merge all child elements\n\t\t\t\t\t\t\t\tvar _t = tokenize(src, null, tag);\n\t\t\t\t\t\t\t\tvar s = 1; // start after open tag\n\t\t\t\t\t\t\t\twhile (/^\\s+$/.test(_t[s].src)) {\n\t\t\t\t\t\t\t\t\ts++; // skip whitespace\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar _p = parseHtml(_t.slice(s, -1), true);\n\t\t\t\t\t\t\t\tvar x = _t.pop();\n\t\t\t\t\t\t\t\tsrc.load().advance(x.pos + x.src.length);\n\t\t\t\t\t\t\t\tif (/^\\s*(\\n|$)/.test(src)) {\n\t\t\t\t\t\t\t\t\tlist.merge(_p);\n\t\t\t\t\t\t\t\t\tsrc.skipWS(); // skip tailing whitespace\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsrc.skipWS();\n\t\t\t\t\t\t\t\tvar _t2 = tokenize(src, null, tag);\n\t\t\t\t\t\t\t\tvar _x = _t2.pop(); // this should be the end tag\n\t\t\t\t\t\t\t\tvar _s = 1; // start after open tag\n\t\t\t\t\t\t\t\twhile (_t2[_s] && /^[\\n\\r]+$/.test(_t2[_s].src)) {\n\t\t\t\t\t\t\t\t\t_s++; // skip whitespace\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_x.tag === tag) {\n\t\t\t\t\t\t\t\t\t// inner can be empty\n\t\t\t\t\t\t\t\t\tvar _inner = _t2.length > 1 ? src.slice(_t2[_s].pos, _x.pos) : '';\n\t\t\t\t\t\t\t\t\tsrc.advance(_x.pos + _x.src.length);\n\t\t\t\t\t\t\t\t\tif (/^\\s*(\\n|$)/.test(src)) {\n\t\t\t\t\t\t\t\t\t\tvar _elm = [tag];\n\t\t\t\t\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\t\t\t\t\t_elm.push(parseHtmlAttr(m[2]));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (tag === 'script' || tag === 'style') {\n\t\t\t\t\t\t\t\t\t\t\t_elm.push(_inner);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvar innerHTML = _inner.replace(/^\\n+/, '').replace(/\\s*$/, '');\n\t\t\t\t\t\t\t\t\t\t\tvar isBlock = /\\n\\r?\\n/.test(innerHTML) || tag === 'ol' || tag === 'ul';\n\t\t\t\t\t\t\t\t\t\t\tvar innerElm = isBlock ? parseFlow(innerHTML, options) : parsePhrase(innerHTML, extend({}, options, { breaks: false }));\n\t\t\t\t\t\t\t\t\t\t\tif (isBlock || /^\\n/.test(_inner)) {\n\t\t\t\t\t\t\t\t\t\t\t\t_elm.push('\\n');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (isBlock || /\\s$/.test(_inner)) {\n\t\t\t\t\t\t\t\t\t\t\t\tinnerElm.push('\\n');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t_elm = _elm.concat(innerElm);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tlist.add(_elm);\n\t\t\t\t\t\t\t\t\t\tsrc.skipWS(); // skip tailing whitespace\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc.load();\n\t\t\t\t\t}\n\n\t\t\t\t\t// ruler\n\t\t\t\t\tif (m = reRuler.exec(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(['hr']);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// list\n\t\t\t\t\tif (m = testList(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(parseList(m[0], options));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// definition list\n\t\t\t\t\tif (m = testDefList(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(parseDefList(m[0], options));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// table\n\t\t\t\t\tif (m = testTable(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(parseTable(m[1], options));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// paragraph\n\t\t\t\t\tm = reBlockNormal.exec(src);\n\t\t\t\t\tlist.merge(paragraph(m[1], 'p', undefined, '\\n', options));\n\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t}\n\n\t\t\t\treturn linkRefs ? fixLinks(list.get(), linkRefs) : list.get();\n\t\t\t}\n\n\t\t\texports.parseFlow = parseFlow;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 7 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function builder(initArr) {\n\t\t\t\tvar arr = Array.isArray(initArr) ? initArr : [];\n\n\t\t\t\treturn {\n\t\t\t\t\tadd: function add(node) {\n\t\t\t\t\t\tif (typeof node === 'string' && typeof arr[arr.length - 1] === 'string') {\n\t\t\t\t\t\t\t// join if possible\n\t\t\t\t\t\t\tarr[arr.length - 1] += node;\n\t\t\t\t\t\t} else if (Array.isArray(node)) {\n\t\t\t\t\t\t\tarr.push(node.filter(function (s) {\n\t\t\t\t\t\t\t\treturn s !== undefined;\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t} else if (node) {\n\t\t\t\t\t\t\tarr.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\tmerge: function merge(arr) {\n\t\t\t\t\t\tfor (var i = 0, l = arr.length; i < l; i++) {\n\t\t\t\t\t\t\tthis.add(arr[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\tlinebreak: function linebreak() {\n\t\t\t\t\t\tif (arr.length) {\n\t\t\t\t\t\t\tthis.add('\\n');\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tget: function get() {\n\t\t\t\t\t\treturn arr;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 8 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n\t\t\t\treturn typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t} : function (obj) {\n\t\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n\t\t\t};\n\n\t\t\t// recurse the tree and swap out any \"href\" attributes\n\t\t\t// this uses the context as the replace dictionary so it can be fed to Array#map\n\t\t\tmodule.exports = function fixLinks(ml, dict) {\n\t\t\t\tif (Array.isArray(ml)) {\n\t\t\t\t\tif (ml[0] === 'a') {\n\t\t\t\t\t\t// found a link\n\t\t\t\t\t\tvar attr = ml[1];\n\t\t\t\t\t\tif ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === 'object' && 'href' in attr && attr.href in dict) {\n\t\t\t\t\t\t\tattr.href = dict[attr.href];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0, l = ml.length; i < l; i++) {\n\t\t\t\t\t\tif (Array.isArray(ml[i])) {\n\t\t\t\t\t\t\tfixLinks(ml[i], dict);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ml;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 9 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/* textile inline parser */\n\n\t\t\tvar ribbon = __webpack_require__(5);\n\t\t\tvar builder = __webpack_require__(7);\n\t\t\tvar re = __webpack_require__(4);\n\n\t\t\tvar _require = __webpack_require__(10),\n\t\t\t    parseAttr = _require.parseAttr;\n\n\t\t\tvar _require2 = __webpack_require__(11),\n\t\t\t    parseGlyph = _require2.parseGlyph;\n\n\t\t\tvar _require3 = __webpack_require__(3),\n\t\t\t    parseHtml = _require3.parseHtml,\n\t\t\t    parseHtmlAttr = _require3.parseHtmlAttr,\n\t\t\t    tokenize = _require3.tokenize,\n\t\t\t    singletons = _require3.singletons,\n\t\t\t    testComment = _require3.testComment,\n\t\t\t    testOpenTag = _require3.testOpenTag;\n\n\t\t\tvar _require4 = __webpack_require__(12),\n\t\t\t    ucaps = _require4.ucaps,\n\t\t\t    txattr = _require4.txattr,\n\t\t\t    txcite = _require4.txcite;\n\n\t\t\tre.pattern.txattr = txattr;\n\t\t\tre.pattern.txcite = txcite;\n\t\t\tre.pattern.ucaps = ucaps;\n\n\t\t\tvar phraseConvert = {\n\t\t\t\t'*': 'strong',\n\t\t\t\t'**': 'b',\n\t\t\t\t'??': 'cite',\n\t\t\t\t'_': 'em',\n\t\t\t\t'__': 'i',\n\t\t\t\t'-': 'del',\n\t\t\t\t'%': 'span',\n\t\t\t\t'+': 'ins',\n\t\t\t\t'~': 'sub',\n\t\t\t\t'^': 'sup',\n\t\t\t\t'@': 'code'\n\t\t\t};\n\n\t\t\tvar rePhrase = /^([\\[\\{]?)(__?|\\*\\*?|\\?\\?|[\\-\\+\\^~@%])/;\n\t\t\tvar reImage = re.compile(/^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/);\n\t\t\tvar reImageFenced = re.compile(/^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/);\n\t\t\t// NB: there is an exception in here to prevent matching \"TM)\"\n\t\t\tvar reCaps = re.compile(/^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/);\n\t\t\tvar reLink = re.compile(/^\"(?!\\s)((?:[^\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/);\n\t\t\tvar reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\n\t\t\tvar reLinkTitle = /\\s*\\(((?:\\([^\\(\\)]*\\)|[^\\(\\)])+)\\)$/;\n\t\t\tvar reFootnote = /^\\[(\\d+)(!?)\\]/;\n\n\t\t\tfunction parsePhrase(src, options) {\n\t\t\t\tsrc = ribbon(src);\n\t\t\t\tvar list = builder();\n\t\t\t\tvar m = void 0;\n\t\t\t\tvar pba = void 0;\n\n\t\t\t\t// loop\n\t\t\t\tdo {\n\t\t\t\t\tsrc.save();\n\n\t\t\t\t\t// linebreak -- having this first keeps it from messing to much with other phrases\n\t\t\t\t\tif (src.startsWith('\\r\\n')) {\n\t\t\t\t\t\tsrc.advance(1); // skip cartridge returns\n\t\t\t\t\t}\n\t\t\t\t\tif (src.startsWith('\\n')) {\n\t\t\t\t\t\tsrc.advance(1);\n\t\t\t\t\t\tif (src.startsWith(' ')) {\n\t\t\t\t\t\t\tsrc.advance(1);\n\t\t\t\t\t\t} else if (options.breaks) {\n\t\t\t\t\t\t\tlist.add(['br']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add('\\n');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// inline notextile\n\t\t\t\t\tif (m = /^==(.*?)==/.exec(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(m[1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// lookbehind => /([\\s>.,\"'?!;:])$/\n\t\t\t\t\tvar behind = src.lookbehind(1);\n\t\t\t\t\tvar boundary = !behind || /^[\\s>.,\"'?!;:()]$/.test(behind);\n\t\t\t\t\t// FIXME: need to test right boundary for phrases as well\n\t\t\t\t\tif ((m = rePhrase.exec(src)) && (boundary || m[1])) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tvar tok = m[2];\n\t\t\t\t\t\tvar fence = m[1];\n\t\t\t\t\t\tvar phraseType = phraseConvert[tok];\n\t\t\t\t\t\tvar code = phraseType === 'code';\n\n\t\t\t\t\t\tif (pba = !code && parseAttr(src, phraseType, tok)) {\n\t\t\t\t\t\t\tsrc.advance(pba[0]);\n\t\t\t\t\t\t\tpba = pba[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n\t\t\t\t\t\t// seek end\n\t\t\t\t\t\tvar mMid = void 0;\n\t\t\t\t\t\tvar mEnd = void 0;\n\t\t\t\t\t\tif (fence === '[') {\n\t\t\t\t\t\t\tmMid = '^(.*?)';\n\t\t\t\t\t\t\tmEnd = '(?:])';\n\t\t\t\t\t\t} else if (fence === '{') {\n\t\t\t\t\t\t\tmMid = '^(.*?)';\n\t\t\t\t\t\t\tmEnd = '(?:})';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar t1 = re.escape(tok.charAt(0));\n\t\t\t\t\t\t\tmMid = code ? '^(\\\\S+|\\\\S+.*?\\\\S)' : '^([^\\\\s' + t1 + ']+|[^\\\\s' + t1 + '].*?\\\\S(' + t1 + '*))';\n\t\t\t\t\t\t\tmEnd = '(?=$|[\\\\s.,\"\\'!?;:()])';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar rx = re.compile(mMid + '(' + re.escape(tok) + ')' + mEnd);\n\t\t\t\t\t\tif ((m = rx.exec(src)) && m[1]) {\n\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\tif (code) {\n\t\t\t\t\t\t\t\tlist.add([phraseType, m[1]]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.add([phraseType, pba].concat(parsePhrase(m[1], options)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// else\n\t\t\t\t\t\tsrc.load();\n\t\t\t\t\t}\n\n\t\t\t\t\t// image\n\t\t\t\t\tif ((m = reImage.exec(src)) || (m = reImageFenced.exec(src))) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\n\t\t\t\t\t\tpba = m[1] && parseAttr(m[1], 'img');\n\t\t\t\t\t\tvar attr = pba ? pba[1] : { 'src': '' };\n\t\t\t\t\t\tvar img = ['img', attr];\n\t\t\t\t\t\tattr.src = m[2];\n\t\t\t\t\t\tattr.alt = m[3] ? attr.title = m[3] : '';\n\n\t\t\t\t\t\tif (m[4]) {\n\t\t\t\t\t\t\t// +cite causes image to be wraped with a link (or link_ref)?\n\t\t\t\t\t\t\t// TODO: support link_ref for image cite\n\t\t\t\t\t\t\timg = ['a', { 'href': m[4] }, img];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(img);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// html comment\n\t\t\t\t\tif (m = testComment(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(['!', m[1]]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// html tag\n\t\t\t\t\t// TODO: this seems to have a lot of overlap with block tags... DRY?\n\t\t\t\t\tif (m = testOpenTag(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tvar tag = m[1];\n\t\t\t\t\t\tvar single = m[3] || m[1] in singletons;\n\t\t\t\t\t\tvar element = [tag];\n\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\telement.push(parseHtmlAttr(m[2]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (single) {\n\t\t\t\t\t\t\t// single tag\n\t\t\t\t\t\t\tlist.add(element).add(src.skipWS());\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// need terminator\n\t\t\t\t\t\t\t// gulp up the rest of this block...\n\t\t\t\t\t\t\tvar reEndTag = re.compile('^(.*?)(</' + tag + '\\\\s*>)', 's');\n\t\t\t\t\t\t\tif (m = reEndTag.exec(src)) {\n\t\t\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\t\t\tif (tag === 'code') {\n\t\t\t\t\t\t\t\t\telement.push(m[1]);\n\t\t\t\t\t\t\t\t} else if (tag === 'notextile') {\n\t\t\t\t\t\t\t\t\t// HTML is still parsed, even though textile is not\n\t\t\t\t\t\t\t\t\tlist.merge(parseHtml(tokenize(m[1])));\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement = element.concat(parsePhrase(m[1], options));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlist.add(element);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// end tag is missing, treat tag as normal text...\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc.load();\n\t\t\t\t\t}\n\n\t\t\t\t\t// footnote\n\t\t\t\t\tif ((m = reFootnote.exec(src)) && /\\S/.test(behind)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tlist.add(['sup', { 'class': 'footnote', 'id': 'fnr' + m[1] }, m[2] === '!' ? m[1] // \"!\" suppresses the link\n\t\t\t\t\t\t: ['a', { href: '#fn' + m[1] }, m[1]]]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// caps / abbr\n\t\t\t\t\tif (m = reCaps.exec(src)) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tvar caps = ['span', { 'class': 'caps' }, m[1]];\n\t\t\t\t\t\tif (m[2]) {\n\t\t\t\t\t\t\t// FIXME: use <abbr>, not acronym!\n\t\t\t\t\t\t\tcaps = ['acronym', { 'title': m[2] }, caps];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(caps);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// links\n\t\t\t\t\tif (boundary && (m = reLink.exec(src)) || (m = reLinkFenced.exec(src))) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tvar title = m[1].match(reLinkTitle);\n\t\t\t\t\t\tvar inner = title ? m[1].slice(0, m[1].length - title[0].length) : m[1];\n\t\t\t\t\t\tif (pba = parseAttr(inner, 'a')) {\n\t\t\t\t\t\t\tinner = inner.slice(pba[0]);\n\t\t\t\t\t\t\tpba = pba[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpba = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (title && !inner) {\n\t\t\t\t\t\t\tinner = title[0];\n\t\t\t\t\t\t\ttitle = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpba.href = m[2];\n\t\t\t\t\t\tif (title) {\n\t\t\t\t\t\t\tpba.title = title[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(['a', pba].concat(parsePhrase(inner.replace(/^(\\.?\\s*)/, ''), options)));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// no match, move by all \"uninteresting\" chars\n\t\t\t\t\tm = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec(src);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\tlist.add(m[0]);\n\t\t\t\t\t}\n\t\t\t\t\tsrc.advance(m ? m[0].length || 1 : 1);\n\t\t\t\t} while (src.valueOf());\n\n\t\t\t\treturn list.get().map(parseGlyph);\n\t\t\t}\n\n\t\t\texports.parsePhrase = parsePhrase;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 10 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tvar reClassid = /^\\(([^\\(\\)\\n]+)\\)/;\n\t\t\tvar rePaddingL = /^(\\(+)/;\n\t\t\tvar rePaddingR = /^(\\)+)/;\n\t\t\tvar reAlignBlock = /^(<>|<|>|=)/;\n\t\t\tvar reAlignImg = /^(<|>|=)/;\n\t\t\tvar reVAlign = /^(~|\\^|\\-)/;\n\t\t\tvar reColSpan = /^\\\\(\\d+)/;\n\t\t\tvar reRowSpan = /^\\/(\\d+)/;\n\t\t\tvar reStyles = /^\\{([^\\}]*)\\}/;\n\t\t\tvar reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\n\t\t\tvar reLang = /^\\[([^\\[\\]\\n]+)\\]/;\n\n\t\t\tvar pbaAlignLookup = {\n\t\t\t\t'<': 'left',\n\t\t\t\t'=': 'center',\n\t\t\t\t'>': 'right',\n\t\t\t\t'<>': 'justify'\n\t\t\t};\n\n\t\t\tvar pbaVAlignLookup = {\n\t\t\t\t'~': 'bottom',\n\t\t\t\t'^': 'top',\n\t\t\t\t'-': 'middle'\n\t\t\t};\n\n\t\t\tfunction copyAttr(s, blacklist) {\n\t\t\t\tif (!s) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tvar d = {};\n\t\t\t\tfor (var k in s) {\n\t\t\t\t\tif (k in s && (!blacklist || !(k in blacklist))) {\n\t\t\t\t\t\td[k] = s[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn d;\n\t\t\t}\n\n\t\t\tfunction testBlock(name) {\n\t\t\t\t// \"in\" test would be better but what about fn#.?\n\t\t\t\treturn (/^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test(name)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t/*\n     The attr bit causes massive problems for span elements when parentheses are used.\n     Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n   \n      RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n      PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n   \n     PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n     following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n     if it is followed by `endToken` or <space>.\n   \n     Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n     attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n     only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n     out there in the real world. So this attempts to emulate the other libraries.\n   */\n\t\t\tfunction parseAttr(input, element, endToken) {\n\t\t\t\tinput = String(input);\n\t\t\t\tif (!input || element === 'notextile') {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tvar m = void 0;\n\t\t\t\tvar st = {};\n\t\t\t\tvar o = { 'style': st };\n\t\t\t\tvar remaining = input;\n\n\t\t\t\tvar isBlock = testBlock(element);\n\t\t\t\tvar isImg = element === 'img';\n\t\t\t\tvar isList = element === 'li';\n\t\t\t\tvar isPhrase = !isBlock && !isImg && element !== 'a';\n\t\t\t\tvar reAlign = isImg ? reAlignImg : reAlignBlock;\n\n\t\t\t\tdo {\n\t\t\t\t\tif (m = reStyles.exec(remaining)) {\n\t\t\t\t\t\tm[1].split(';').forEach(function (p) {\n\t\t\t\t\t\t\tvar d = p.match(reCSS);\n\t\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\t\tst[d[1]] = d[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m = reLang.exec(remaining)) {\n\t\t\t\t\t\tvar rm = remaining.slice(m[0].length);\n\t\t\t\t\t\tif (!rm && isPhrase || endToken && endToken === rm.slice(0, endToken.length)) {\n\t\t\t\t\t\t\tm = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\to['lang'] = m[1];\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m = reClassid.exec(remaining)) {\n\t\t\t\t\t\tvar _rm = remaining.slice(m[0].length);\n\t\t\t\t\t\tif (!_rm && isPhrase || endToken && (_rm[0] === ' ' || endToken === _rm.slice(0, endToken.length))) {\n\t\t\t\t\t\t\tm = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar bits = m[1].split('#');\n\t\t\t\t\t\t\tif (bits[0]) {\n\t\t\t\t\t\t\t\to.class = bits[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bits[1]) {\n\t\t\t\t\t\t\t\to.id = bits[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremaining = _rm;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isBlock || isList) {\n\t\t\t\t\t\tif (m = rePaddingL.exec(remaining)) {\n\t\t\t\t\t\t\tst['padding-left'] = m[1].length + 'em';\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m = rePaddingR.exec(remaining)) {\n\t\t\t\t\t\t\tst['padding-right'] = m[1].length + 'em';\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only for blocks:\n\t\t\t\t\tif (isImg || isBlock || isList) {\n\t\t\t\t\t\tif (m = reAlign.exec(remaining)) {\n\t\t\t\t\t\t\tvar align = pbaAlignLookup[m[1]];\n\t\t\t\t\t\t\tif (isImg) {\n\t\t\t\t\t\t\t\to['align'] = align;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tst['text-align'] = align;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only for table cells\n\t\t\t\t\tif (element === 'td' || element === 'tr') {\n\t\t\t\t\t\tif (m = reVAlign.exec(remaining)) {\n\t\t\t\t\t\t\tst['vertical-align'] = pbaVAlignLookup[m[1]];\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (element === 'td') {\n\t\t\t\t\t\tif (m = reColSpan.exec(remaining)) {\n\t\t\t\t\t\t\to['colspan'] = m[1];\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m = reRowSpan.exec(remaining)) {\n\t\t\t\t\t\t\to['rowspan'] = m[1];\n\t\t\t\t\t\t\tremaining = remaining.slice(m[0].length);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (m);\n\n\t\t\t\t// collapse styles\n\t\t\t\tvar s = [];\n\t\t\t\tfor (var v in st) {\n\t\t\t\t\ts.push(v + ':' + st[v]);\n\t\t\t\t}\n\t\t\t\tif (s.length) {\n\t\t\t\t\to.style = s.join(';');\n\t\t\t\t} else {\n\t\t\t\t\tdelete o.style;\n\t\t\t\t}\n\n\t\t\t\treturn remaining === input ? undefined : [input.length - remaining.length, o];\n\t\t\t}\n\n\t\t\tmodule.exports = {\n\t\t\t\tcopyAttr: copyAttr,\n\t\t\t\tparseAttr: parseAttr\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 11 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/* textile glyph parser */\n\n\t\t\tvar re = __webpack_require__(4);\n\n\t\t\tvar reApostrophe = /(\\w)'(\\w)/g;\n\t\t\tvar reArrow = /([^\\-]|^)->/;\n\t\t\tvar reClosingDQuote = re.compile(/([^\\s\\[\\(])\"(?=$|\\s|[:punct:])/g);\n\t\t\tvar reClosingSQuote = re.compile(/([^\\s\\[\\(])'(?=$|\\s|[:punct:])/g);\n\t\t\tvar reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\n\t\t\tvar reDimsign = /([\\d\\.,]+['\"]? ?)x( ?)(?=[\\d\\.,]['\"]?)/g;\n\t\t\tvar reDoublePrime = re.compile(/(\\d*[\\.,]?\\d+)\"(?=\\s|$|[:punct:])/g);\n\t\t\tvar reEllipsis = /([^.]?)\\.{3}/g;\n\t\t\tvar reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\n\t\t\tvar reEndash = / - /g;\n\t\t\tvar reOpenDQuote = /\"/g;\n\t\t\tvar reOpenSQuote = /'/g;\n\t\t\tvar reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\n\t\t\tvar reSinglePrime = re.compile(/(\\d*[\\.,]?\\d+)'(?=\\s|$|[:punct:])/g);\n\t\t\tvar reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\n\t\t\texports.parseGlyph = function parseGlyph(src) {\n\t\t\t\tif (typeof src !== 'string') {\n\t\t\t\t\treturn src;\n\t\t\t\t}\n\t\t\t\t// NB: order is important here ...\n\t\t\t\treturn src.replace(reArrow, '$1&#8594;').replace(reDimsign, '$1&#215;$2').replace(reEllipsis, '$1&#8230;').replace(reEmdash, '$1&#8212;$2').replace(reEndash, ' &#8211; ').replace(reTrademark, '$1&#8482;').replace(reRegistered, '$1&#174;').replace(reCopyright, '$1&#169;')\n\t\t\t\t// double quotes\n\t\t\t\t.replace(reDoublePrime, '$1&#8243;').replace(reClosingDQuote, '$1&#8221;').replace(reOpenDQuote, '&#8220;')\n\t\t\t\t// single quotes\n\t\t\t\t.replace(reSinglePrime, '$1&#8242;').replace(reApostrophe, '$1&#8217;$2').replace(reClosingSQuote, '$1&#8217;').replace(reOpenSQuote, '&#8216;')\n\t\t\t\t// fractions and degrees\n\t\t\t\t.replace(/[\\(\\[]1\\/4[\\]\\)]/, '&#188;').replace(/[\\(\\[]1\\/2[\\]\\)]/, '&#189;').replace(/[\\(\\[]3\\/4[\\]\\)]/, '&#190;').replace(/[\\(\\[]o[\\]\\)]/, '&#176;').replace(/[\\(\\[]\\+\\/\\-[\\]\\)]/, '&#177;');\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 12 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\t/* eslint camelcase: 0 */\n\n\t\t\texports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\n\t\t\texports.ucaps = 'A-Z' +\n\t\t\t// Latin extended -\n\t\t\t'\\xC0-\\xD6\\xD8-\\xDE' +\n\t\t\t// Latin caps with embelishments and ligatures...\n\t\t\t'\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F' + '\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D' + '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC' + '\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE' + '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E' + '\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E' + '\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40' + '\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E' + '\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE' + '\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE' + '\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E\\u2C7F' + '\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E' + '\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E' + '\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA';\n\n\t\t\texports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\n\t\t\tvar attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\n\t\t\tvar attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\n\t\t\tvar attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\n\t\t\tvar attr_align = exports.attr_align = '(?:<>|<|>|=)';\n\t\t\tvar attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\n\t\t\tvar txattr = exports.txattr = '(?:' + attr_class + '|' + attr_style + '|' + attr_lang + '|' + attr_align + '|' + attr_pad + ')*';\n\n\t\t\texports.txlisthd = '[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)' + txattr + '(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))';\n\n\t\t\t/***/\n\t\t},\n\t\t/* 13 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/* textile list parser */\n\n\t\t\tvar ribbon = __webpack_require__(5);\n\t\t\tvar re = __webpack_require__(4);\n\t\t\tvar merge = __webpack_require__(1);\n\n\t\t\tvar _require = __webpack_require__(10),\n\t\t\t    parseAttr = _require.parseAttr;\n\n\t\t\tvar _require2 = __webpack_require__(9),\n\t\t\t    parsePhrase = _require2.parsePhrase;\n\n\t\t\tvar _require3 = __webpack_require__(12),\n\t\t\t    txlisthd = _require3.txlisthd;\n\n\t\t\tre.pattern.txlisthd = txlisthd;\n\t\t\tvar reList = re.compile(/^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's');\n\t\t\tvar reItem = re.compile(/^([#\\*]+)([^\\0]+?)(\\n(?=[:txlisthd:])|$)/, 's');\n\n\t\t\tfunction listPad(n) {\n\t\t\t\tvar s = '\\n';\n\t\t\t\twhile (n--) {\n\t\t\t\t\ts += '\\t';\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tfunction testList(src) {\n\t\t\t\treturn reList.exec(src);\n\t\t\t}\n\n\t\t\tfunction parseList(src, options) {\n\t\t\t\tsrc = ribbon(src.replace(/(^|\\r?\\n)[\\t ]+/, '$1'));\n\n\t\t\t\tvar stack = [];\n\t\t\t\tvar currIndex = {};\n\t\t\t\tvar lastIndex = options._lst || {};\n\t\t\t\tvar itemIndex = 0;\n\t\t\t\tvar listAttr = void 0;\n\t\t\t\tvar m = void 0;\n\t\t\t\tvar n = void 0;\n\t\t\t\tvar s = void 0;\n\n\t\t\t\twhile (m = reItem.exec(src)) {\n\t\t\t\t\tvar item = ['li'];\n\t\t\t\t\tvar destLevel = m[1].length;\n\t\t\t\t\tvar type = m[1].substr(-1) === '#' ? 'ol' : 'ul';\n\t\t\t\t\tvar newLi = null;\n\t\t\t\t\tvar lst = void 0;\n\t\t\t\t\tvar par = void 0;\n\t\t\t\t\tvar pba = void 0;\n\t\t\t\t\tvar r = void 0;\n\n\t\t\t\t\t// list starts and continuations\n\t\t\t\t\tif (n = /^(_|\\d+)/.exec(m[2])) {\n\t\t\t\t\t\titemIndex = isFinite(n[1]) ? parseInt(n[1], 10) : lastIndex[destLevel] || currIndex[destLevel] || 1;\n\t\t\t\t\t\tm[2] = m[2].slice(n[1].length);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pba = parseAttr(m[2], 'li')) {\n\t\t\t\t\t\tm[2] = m[2].slice(pba[0]);\n\t\t\t\t\t\tpba = pba[1];\n\t\t\t\t\t}\n\n\t\t\t\t\t// list control\n\t\t\t\t\tif (/^\\.\\s*$/.test(m[2])) {\n\t\t\t\t\t\tlistAttr = pba || {};\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// create nesting until we have correct level\n\t\t\t\t\twhile (stack.length < destLevel) {\n\t\t\t\t\t\t// list always has an attribute object, this simplifies first-pba resolution\n\t\t\t\t\t\tlst = [type, {}, listPad(stack.length + 1), newLi = ['li']];\n\t\t\t\t\t\tpar = stack[stack.length - 1];\n\t\t\t\t\t\tif (par) {\n\t\t\t\t\t\t\tpar.li.push(listPad(stack.length));\n\t\t\t\t\t\t\tpar.li.push(lst);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\tul: lst,\n\t\t\t\t\t\t\tli: newLi,\n\t\t\t\t\t\t\t// count attributes's found per list\n\t\t\t\t\t\t\tatt: 0\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcurrIndex[stack.length] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove nesting until we have correct level\n\t\t\t\t\twhile (stack.length > destLevel) {\n\t\t\t\t\t\tr = stack.pop();\n\t\t\t\t\t\tr.ul.push(listPad(stack.length));\n\t\t\t\t\t\t// lists have a predictable structure - move pba from listitem to list\n\t\t\t\t\t\tif (r.att === 1 && !r.ul[3][1].substr) {\n\t\t\t\t\t\t\tmerge(r.ul[1], r.ul[3].splice(1, 1)[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// parent list\n\t\t\t\t\tpar = stack[stack.length - 1];\n\n\t\t\t\t\tif (itemIndex) {\n\t\t\t\t\t\tpar.ul[1].start = itemIndex;\n\t\t\t\t\t\tcurrIndex[destLevel] = itemIndex;\n\t\t\t\t\t\t// falsy prevents this from fireing until it is set again\n\t\t\t\t\t\titemIndex = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (listAttr) {\n\t\t\t\t\t\t// \"more than 1\" prevent attribute transfers on list close\n\t\t\t\t\t\tpar.att = 9;\n\t\t\t\t\t\tmerge(par.ul[1], listAttr);\n\t\t\t\t\t\tlistAttr = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!newLi) {\n\t\t\t\t\t\tpar.ul.push(listPad(stack.length), item);\n\t\t\t\t\t\tpar.li = item;\n\t\t\t\t\t}\n\t\t\t\t\tif (pba) {\n\t\t\t\t\t\tpar.li.push(pba);\n\t\t\t\t\t\tpar.att++;\n\t\t\t\t\t}\n\t\t\t\t\tArray.prototype.push.apply(par.li, parsePhrase(m[2].trim(), options));\n\n\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\tcurrIndex[destLevel] = (currIndex[destLevel] || 0) + 1;\n\t\t\t\t}\n\n\t\t\t\t// remember indexes for continuations next time\n\t\t\t\toptions._lst = currIndex;\n\n\t\t\t\twhile (stack.length) {\n\t\t\t\t\ts = stack.pop();\n\t\t\t\t\ts.ul.push(listPad(stack.length));\n\t\t\t\t\t// lists have a predictable structure - move pba from listitem to list\n\t\t\t\t\tif (s.att === 1 && !s.ul[3][1].substr) {\n\t\t\t\t\t\tmerge(s.ul[1], s.ul[3].splice(1, 1)[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn s.ul;\n\t\t\t}\n\n\t\t\tmodule.exports = {\n\t\t\t\ttestList: testList,\n\t\t\t\tparseList: parseList\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 14 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/* definitions list parser */\n\n\t\t\tvar ribbon = __webpack_require__(5);\n\n\t\t\tvar reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\n\t\t\tvar reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\n\t\t\tfunction testDefList(src) {\n\t\t\t\treturn reDeflist.exec(src);\n\t\t\t}\n\n\t\t\tfunction parseDefList(src, options) {\n\t\t\t\tsrc = ribbon(src.trim());\n\n\t\t\t\t// late loading to get around the lack of non-circular-dependency support in RequireJS\n\t\t\t\tvar parsePhrase = __webpack_require__(9).parsePhrase;\n\t\t\t\tvar parseFlow = __webpack_require__(6).parseFlow;\n\n\t\t\t\tvar deflist = ['dl', '\\n'];\n\t\t\t\tvar terms = void 0;\n\t\t\t\tvar def = void 0;\n\t\t\t\tvar m = void 0;\n\n\t\t\t\twhile (m = reItem.exec(src)) {\n\t\t\t\t\t// add terms\n\t\t\t\t\tterms = m[1].split(/(?:^|\\n)\\- /).slice(1);\n\t\t\t\t\twhile (terms.length) {\n\t\t\t\t\t\tdeflist.push('\\t', ['dt'].concat(parsePhrase(terms.shift().trim(), options)), '\\n');\n\t\t\t\t\t}\n\t\t\t\t\t// add definitions\n\t\t\t\t\tdef = m[2].trim();\n\t\t\t\t\tdeflist.push('\\t', ['dd'].concat(/=:$/.test(def) ? parseFlow(def.slice(0, -2).trim(), options) : parsePhrase(def, options)), '\\n');\n\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t}\n\t\t\t\treturn deflist;\n\t\t\t}\n\n\t\t\texports.testDefList = testDefList;\n\t\t\texports.parseDefList = parseDefList;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 15 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\t/* textile table parser */\n\n\t\t\tvar re = __webpack_require__(4);\n\t\t\tvar merge = __webpack_require__(1);\n\t\t\tvar ribbon = __webpack_require__(5);\n\n\t\t\tvar _require = __webpack_require__(10),\n\t\t\t    parseAttr = _require.parseAttr;\n\n\t\t\tvar _require2 = __webpack_require__(9),\n\t\t\t    parsePhrase = _require2.parsePhrase;\n\n\t\t\tvar _require3 = __webpack_require__(2),\n\t\t\t    reIndent = _require3.reIndent;\n\n\t\t\tvar _require4 = __webpack_require__(12),\n\t\t\t    txattr = _require4.txattr;\n\n\t\t\tre.pattern.txattr = txattr;\n\n\t\t\tvar reTable = re.compile(/^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n)?/, 's');\n\t\t\tvar reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\n\t\t\tvar reRow = re.compile(/^(?:\\|([~\\^\\-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's');\n\t\t\tvar reCaption = /^\\|=([^\\n+]*)\\n/;\n\t\t\tvar reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\n\t\t\tvar reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\n\t\t\tvar charToTag = {\n\t\t\t\t'^': 'thead',\n\t\t\t\t'~': 'tfoot',\n\t\t\t\t'-': 'tbody'\n\t\t\t};\n\n\t\t\tfunction parseColgroup(src) {\n\t\t\t\tvar colgroup = ['colgroup', {}];\n\t\t\t\tsrc.split('|').forEach(function (s, isCol) {\n\t\t\t\t\tvar col = isCol ? {} : colgroup[1];\n\t\t\t\t\tvar d = s.trim();\n\t\t\t\t\tvar m = void 0;\n\t\t\t\t\tif (d) {\n\t\t\t\t\t\tif (m = /^\\\\(\\d+)/.exec(d)) {\n\t\t\t\t\t\t\tcol.span = +m[1];\n\t\t\t\t\t\t\td = d.slice(m[0].length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m = parseAttr(d, 'col')) {\n\t\t\t\t\t\t\tmerge(col, m[1]);\n\t\t\t\t\t\t\td = d.slice(m[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m = /\\b\\d+\\b/.exec(d)) {\n\t\t\t\t\t\t\tcol.width = +m[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isCol) {\n\t\t\t\t\t\tcolgroup.push('\\n\\t\\t', ['col', col]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn colgroup.concat(['\\n\\t']);\n\t\t\t}\n\n\t\t\tfunction testTable(src) {\n\t\t\t\treturn reTable.exec(src);\n\t\t\t}\n\n\t\t\tfunction parseTable(src, options) {\n\t\t\t\tsrc = ribbon(src.trim());\n\n\t\t\t\tvar rowgroups = [];\n\t\t\t\tvar colgroup = void 0;\n\t\t\t\tvar caption = void 0;\n\t\t\t\tvar tAttr = {};\n\t\t\t\tvar tCurr = void 0;\n\t\t\t\tvar row = void 0;\n\t\t\t\tvar inner = void 0;\n\t\t\t\tvar pba = void 0;\n\t\t\t\tvar more = void 0;\n\t\t\t\tvar m = void 0;\n\t\t\t\tvar extended = 0;\n\n\t\t\t\tvar setRowGroup = function setRowGroup(type, pba) {\n\t\t\t\t\ttCurr = [type, pba || {}];\n\t\t\t\t\trowgroups.push(tCurr);\n\t\t\t\t};\n\n\t\t\t\tif (m = reHead.exec(src)) {\n\t\t\t\t\t// parse and apply table attr\n\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\tpba = parseAttr(m[2], 'table');\n\t\t\t\t\tif (pba) {\n\t\t\t\t\t\tmerge(tAttr, pba[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (m[3]) {\n\t\t\t\t\t\ttAttr.summary = m[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// caption\n\t\t\t\tif (m = reCaption.exec(src)) {\n\t\t\t\t\tcaption = ['caption'];\n\t\t\t\t\tif (pba = parseAttr(m[1], 'caption')) {\n\t\t\t\t\t\tcaption.push(pba[1]);\n\t\t\t\t\t\tm[1] = m[1].slice(pba[0]);\n\t\t\t\t\t}\n\t\t\t\t\tif (/\\./.test(m[1])) {\n\t\t\t\t\t\t// mandatory \".\"\n\t\t\t\t\t\tcaption.push(m[1].slice(1).replace(/\\|\\s*$/, '').trim());\n\t\t\t\t\t\textended++;\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcaption = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\t// colgroup\n\t\t\t\t\tif (m = reColgroup.exec(src)) {\n\t\t\t\t\t\tcolgroup = parseColgroup(m[1]);\n\t\t\t\t\t\textended++;\n\t\t\t\t\t}\n\t\t\t\t\t// \"rowgroup\" (tbody, thead, tfoot)\n\t\t\t\t\telse if (m = reRowgroup.exec(src)) {\n\t\t\t\t\t\t\t// PHP allows any amount of these in any order\n\t\t\t\t\t\t\t// and simply translates them straight through\n\t\t\t\t\t\t\t// the same is done here.\n\t\t\t\t\t\t\tvar tag = charToTag[m[1]] || 'tbody';\n\t\t\t\t\t\t\tpba = parseAttr(m[2] + ' ', tag);\n\t\t\t\t\t\t\tsetRowGroup(tag, pba && pba[1]);\n\t\t\t\t\t\t\textended++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// row\n\t\t\t\t\t\telse if (m = reRow.exec(src)) {\n\t\t\t\t\t\t\t\tif (!tCurr) {\n\t\t\t\t\t\t\t\t\tsetRowGroup('tbody');\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trow = ['tr'];\n\n\t\t\t\t\t\t\t\tif (m[2] && (pba = parseAttr(m[2], 'tr'))) {\n\t\t\t\t\t\t\t\t\t// FIXME: requires \"\\.\\s?\" -- else what ?\n\t\t\t\t\t\t\t\t\trow.push(pba[1]);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttCurr.push('\\n\\t\\t', row);\n\t\t\t\t\t\t\t\tinner = ribbon(m[3]);\n\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tinner.save();\n\n\t\t\t\t\t\t\t\t\t// cell loop\n\t\t\t\t\t\t\t\t\tvar th = inner.startsWith('_');\n\t\t\t\t\t\t\t\t\tvar cell = [th ? 'th' : 'td'];\n\t\t\t\t\t\t\t\t\tif (th) {\n\t\t\t\t\t\t\t\t\t\tinner.advance(1);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tpba = parseAttr(inner, 'td');\n\t\t\t\t\t\t\t\t\tif (pba) {\n\t\t\t\t\t\t\t\t\t\tinner.advance(pba[0]);\n\t\t\t\t\t\t\t\t\t\tcell.push(pba[1]); // FIXME: don't do this if next text fails\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (pba || th) {\n\t\t\t\t\t\t\t\t\t\tvar p = /^\\.\\s*/.exec(inner);\n\t\t\t\t\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\t\t\t\t\tinner.advance(p[0]);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcell = ['td'];\n\t\t\t\t\t\t\t\t\t\t\tinner.load();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar mx = /^(==.*?==|[^\\|])*/.exec(inner);\n\t\t\t\t\t\t\t\t\tcell = cell.concat(parsePhrase(mx[0], options));\n\t\t\t\t\t\t\t\t\trow.push('\\n\\t\\t\\t', cell);\n\t\t\t\t\t\t\t\t\tmore = inner.valueOf().charAt(mx[0].length) === '|';\n\t\t\t\t\t\t\t\t\tinner.advance(mx[0].length + 1);\n\t\t\t\t\t\t\t\t} while (more);\n\n\t\t\t\t\t\t\t\trow.push('\\n\\t\\t');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t//\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\tsrc.advance(m[0]);\n\t\t\t\t\t}\n\t\t\t\t} while (m);\n\n\t\t\t\t// assemble table\n\t\t\t\tvar table = ['table', tAttr];\n\t\t\t\tif (extended) {\n\t\t\t\t\tif (caption) {\n\t\t\t\t\t\ttable.push('\\n\\t', caption);\n\t\t\t\t\t}\n\t\t\t\t\tif (colgroup) {\n\t\t\t\t\t\ttable.push('\\n\\t', colgroup);\n\t\t\t\t\t}\n\t\t\t\t\trowgroups.forEach(function (tbody) {\n\t\t\t\t\t\ttable.push('\\n\\t', tbody.concat(['\\n\\t']));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttable = table.concat(reIndent(rowgroups[0].slice(2), -1));\n\t\t\t\t}\n\n\t\t\t\ttable.push('\\n');\n\t\t\t\treturn table;\n\t\t\t}\n\n\t\t\tmodule.exports = {\n\t\t\t\tparseColgroup: parseColgroup,\n\t\t\t\tparseTable: parseTable,\n\t\t\t\ttestTable: testTable\n\t\t\t};\n\n\t\t\t/***/\n\t\t}]\n\t\t/******/)\n\t);\n});\n;\n//# sourceMappingURL=textile.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/textile-js/lib/textile.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ })

}]);